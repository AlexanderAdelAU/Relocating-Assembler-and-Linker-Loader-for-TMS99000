;***************************
;
; SMALL-VM VERSION 1.1	
;
;*****************************
;
	ORG	0B000H	
	B	@TRAP	 	;;SKIPPTED IF LOADED WITH PROGRAM
	B	@CC9998	 	;;EXECUTED ONLY IF LOADED WITH PROG
CCEOM	WORD	0B000H	 	;;NONIMAL END OF MEM
	B	@CCBOJ	
	B	@CCEXIT	
	B	@CCPOLL	
	B	@CCHALT	
	B	@CCOPEN	
	B	@CCCLOSE	
	B	@CCREAD	
	B	@CCWRITE	
	B	@CCSEEK	
	B	@CCFILE	
	B	@CCPURGE	
	B	@CCFLUSH	
	B	@CCALLOC	
	B	@CCFREE	
	B	@CCAVAIL	
	B	@CCDELIM	
;
;---DIVERT	CIN	CALLS	TO CINTRAP
;
TRAP	LI	R1,FUN01	 
	INCT	R1	 	;;->ADDR
	MOV	*R1,@CINV	 ;;SAVE VECTOR
	LI	R2,CINTRAP	
	MOV	R2,*R1	
	B	@SHELL	
;
;DOS.EQUATES
;	
BDOS	EQU	4
CIN	EQU	1	 	;;CONSOLE INPUT
COUT	EQU	2	 	;;CONSOLE OUTPUT
SELDSK	EQU	14	 	;;SELECT A DISK
RDRND	EQU	33	 	;;READ RANDOM
WRRND	EQU	34	 	;;WRITE RANDOM
DLOOK	EQU	17	 	;;SEARCH DIRECTORY
ERAFIL	EQU	19	 	;;ERASE FILE
SETDMA	EQU	26	 	;;SET DMA ADDRESS
MAKFIL	EQU	22	 	;;MAKE A FILE
OPENF	EQU	15	 	;;OPEN FILE
CLOSEF	EQU	16	 	;;CLOSE FILE
RDRND	EQU	33	 	;;READ RANDOM RECORD
WRRND	EQU	34	 	;;WRITE RANDOM RECORD
MINUS1	EQU	-1
;
;---SHELL	ENTRY	POINTS	
;
SHELL	B	@0		;;SHELL ADDR
CMDBF	EQU	82H	 	;;COMMAND BUFFER IN SHELL
CONFG	WORD	0	 	;;Q1,....F2...
;
;---MISC	ASSEMBLY	CONSTANTS
;
AMAX	EQU	7		;;#OF AUX I/O PORTS
FMAX	EQU	8		;;#OF OPEN FILES
BLKSZ	EQU	2048		;;DISK BLOCK SIZE
DDEN	EQU	1		;;DRIVE DENSITY-1=SD,2=DD
DSKSZ	EQU	225	 	;;SECTORS PER SIDE OF DISK
BPAD	EQU	0		;;BUFFER PAD BYTE
FCBONLY	EQU	0		;;OPEN MODE=ALLOC FCB ONLY
RD	EQU	1	 	;;OPEN MODE=READ
WRT	EQU	2	 	;;WRITE MODE=WRITE
RDWRT	EQU	3	 	;;OPEN MODE=READ/WRITE
DCOMR	EQU	1	 	;;DCOM READ COMMAND
DCOMW	EQU	2	 	;;DCOM WRITE COMMAND
;
;----FILE	DISCRIPTOR	BLOCKS(FDB)
;
FDBSZ	EQU	6	 	;;SIZE OF FDB ENTRY
FMODE	EQU	0	 	;;OFFSET TO OPEN MODE
FDEV	EQU	2	 	;;OFFSET TO PERIPHERAL
FFCB	EQU	4	 	;;OFFSET TO ADDR OF CORR FCB
;----FD	0
FDB	WORD	1		;;STDIN OPEN FOR RD
	WORD	0	 	;;STDIN=DEV 0--CONSOLE
	WORD	0	 	;;STDIN HAS NO FCB
;----FD	1
	WORD	2		;;STDOUT OPEN FOR WRT
	WORD	0	 	;;STDOUT=DEV 0 -- CONSOLE
	WORD	0	 	;;STDOUT HAS NO FCB 
*----FD	2
	WORD	3	 	;;STDERR OPEN FOR RD/WRT
	WORD	0	 	;;STDERR=DEV 0 --CONSOLE(ALWAYS)
	WORD	0	 	;;STDERR HAS NO FCB
*----FD3
	WORD	3	 	;;AUX PORTS FOR RD/WRT
	WORD	1	 	;;DEVICE 1
	WORD	0	 	;;NO DCB'S
*---FD4
	WORD	3	
	WORD	2	
	WORD	0	
*---FD5
	WORD	3	
	WORD	3	 
	WORD	0	
*---FD6
	WORD	3	
	WORD	4	 
	WORD	0	
*---FD7	
	WORD	3	
	WORD	5	 
	WORD	0	
*---FD8
	WORD	3	
	WORD	6	 
	WORD	0	
*---FD9
	WORD	3	
	WORD	7	 
	WORD	0	
*---FD10
	WORD	0	 
	WORD	0	 
	WORD	0	 
*--FD11
	WORD	0	
	WORD	0	
	WORD	0	
*--FD12	
	WORD	0	
	WORD	0	
	WORD	0	
*--FD13	
	WORD	0	
	WORD	0	
	WORD	0	
*---FD14
	WORD	0	
	WORD	0	
	WORD	0	
*---FD15	
	WORD	0	
	WORD	0	
	WORD	0	
*---FD16
	WORD	0	
	WORD	0	
	WORD	0	
*---FD17
	WORD	0	
	WORD	0	
	WORD	0	
;
FDBV	WORD	0	 	;;CURRENT FDB VECTOR
;
;---FILE	CONTROL	BLOCKS(FCB'S)
;
;---FILE-DIRECTORY	ENTRY	OFFSETS
;
NAM	EQU	0	 	;;FILE NAME
RIB	EQU	10	 	;;FILE DISK MAP
FTY	EQU	12	 	;;TYPE
FSZ	EQU	14	 	;;SIZE(SECTORS)
;
;----OTHER OFFSETS
;
NRR	EQU	16	 	;;NEXT RECORD TO READ/WRITE
DRV	EQU	18	 	;;DRIVE NO.
DEN	EQU	20	 	;;DIRECTORY ENTRY NO.
SBS	EQU	22	 	;;START BUFFER START ADDR
SBE	EQU	24	 	;;SECTOR BUFFER END ADDR
CHG	EQU	26	 	;;0=NO CHANGE,1=BUFFER CHANGED
NBB	EQU	28	 	;;NXT BYTE IN BUFFER
CBF	EQU	30	 	;;CUR BUFFER IN FILE
BSZ	EQU	32	 	;;BUFFER SIZE
TSC	EQU	34	 	;;TRK/SCT LIST CHANGE FLAG 
CAT	EQU	36	 	;;CURRENT ALLOC TRACK
CAS	EQU	38		;;CURRENT ALLOC SECTOR
NSL	EQU	40	 	;;NO. OF SECTORS LEFT THIS TRACK
TBM	EQU	42	 	;;TRACK BIT MAP
TSL	EQU	44	 	;;TRACK/SECTOR LIST
FRI	EQU	284	 	;;FILE RETRIEVAL INFO- IN TS LIST
BUF	EQU	300		;;BUFFER
;	
;-FCB'S	ARE	ALLOCATED	BY ALLOC
;
FCBSZ	EQU	554	 	;;SIZE OF FCB
;
FCBV	WORD	0	 	;;CURRENT FCB VECTOR
;
;-----CALL	PARAMETERS
;
CPTDI	BSS	2	 	;;OPEN-TYPE DEP. INFO
CPTYPE	BSS	2	 	;;OPEN FILE TYPE
CPBASE	BSS	2	 	;;SEEK-BASE
CPSIZE	EQU	CPBASE		;;OPEN-FILE SIZE(256 BLOCKS)
CPMODE	BSS	2	 	;;OPEN-MODE
CPRECSZ	EQU	CPMODE		;;READ/WRITE - RECORD SIZE
CPDISP	EQU	CPMODE		;;SEEK - DISPLACEMENT(32 BITS)
CPADDR	EQU	CPMODE		;;FREE-MEM ADDR
CPNAME	BSS	2	 	;;OPEN-FILE NAME ADDR
CPREC	EQU	CPNAME		;;READ/WRITE - RECORD ADDR
CPFD	BSS	2	 	;;FILE DESCRIPTOR
;
;---IO	PARAMTER	PACKET	STORAGE 
;
IOSTAT	BSS	2		;;RETURN STATUS
IOTRK	BSS	2		;;IO TRACK
IOSEC	BSS	2	 	;;IO SECTOR
IOADDR	BSS	2		;;ADDR OF BUFFER
NOSECT	BSS	2		;;NO OF SECTORS TO IO
;
;
;----MISC	STORAGE
;
TMSK1	WORD	8000H	 	;;TERMINATOR MASK
UPCSW	WORD	1	 	;;IGNORE CTL-C'S IF ZERO
EOP	WORD	0	 	;;END OF PROGRAM
FREEMEM	WORD	0	 	;;CURRENT FREE MEM PTR
SOB	WORD	0	 	;;START OF CMD LINE BUFFER
ARGC	WORD	0	 	;;ARGUMENT COUNT FOR MAIN
RFD	WORD	17	 	;;NEXT REDIR FD
BOJRET	WORD	0	 	;;ADDR FOR RET TO PROG
FDBVTMP	WORD	0	 	;;HOLD FDBV
CINV	WORD	0	 	;;CINV IF LOADED WITH PROG
FDETMP	BSS	18		;;TEMP FILE DIRECTORY ENTRY
DIRENT	BSS	2	 	;;CURRENT DIRECTORY OFFSET
CSECT	BSS	2	 	;;TEMP SECTOR
CTRK	BSS	2	 	;;TEMP TRACK
;
SPACE	WORD	>200D	 	;;SPACE-CR
CR	WORD	>0D00	 	;;
LPNT	WORD	>3C00	 ;"<"
RPNT	WORD	>3E00	 ;">"
NCDA	WORD	0	 	;;NEXT CURREN DISK ADDR
NCBF	WORD	0	 ;
NNBB	WORD	0	;
SAVSP	WORD	0	;NON ZERO ON PROGRAM HALT ONLY(CTL-C)
SAVSL	WORD	0	 	;;STACK LIMIT
DIRPNT	WORD	0	 	;;CURRENT DIR PNTR
TEMP	WORD	0	;
CMD	WORD	0	;
DATA	WORD	0	;
DBYTE	WORD	0	;
DFLAG	WORD	0	;
*
*
*----CCBOJ()	STACK=RETURN	ADDR,
*
CCBOJ	MOV	@CINV,R4	 	;;LOADED WITH PROG?
	JNE	BOJ0	 ;NO
	MOV	@SAVSP,R4	 	;;YES-THEN PROG HALTED? 
	JEQ	BOJ0	
	B	@REENTER	 ;YES-THEN CONTINE IT
BOJ0	XOP	@BOJRET,3	 	;;POP RET ADDR INTO BOJRET
	MOV	@CCEOM,R10		;;SET SP TO CCEOM
	MOV	R3,@EOP	 	;;R3->END OF PROG
	MOV	R3,@FREEMEM	 	;;INIT FREE MEM PTR
	MOV	R3,R9		;;SET STACK LIMIT
	LI	R4,FDEV	 	;;UNDIRECT STDIN
	CLR	@FDB(R4)	
	AI	R4,FDBSZ	 	;;POINT TO NEXT FDB
	CLR	@FDB(R4)	 	;;UNDIRECT STDOUT
	CLR	@DFLAG	 	;;RESET DELIM FLAG
	LI	R4,AMAX	  
	AI	R4,FMAX	;
	INCT	R4	 ;
	MOV	R4,@RFD	 	;;RESET 1ST REDIR FD
	LI	R1,AMAX	 
	AI	R1,3	 	;;1ST FILE FD
BOJ1	XOP	@LOCFDB,0	 ;R4=FDB VECTOR (CAN'T)FAIL
	MOV	R4,@FDBV	;
	CLR	@FMODE(R4)		;;MARK FD CLOSED 
	CLR	@FFCB(R4)	 ;;NO FCB ALLOCATED 
	INC	R1		;;UP FD COUNT 
	LI	R0,AMAX	 
	AI	R0,FMAX	 
	AI	R0,3	 	;;AMAX+FMAX+3
	C	R0,R1		;;LAST FILE FD+1
	JH	BOJ1	;
	CLR	@SAVSP	 	;;MAKE CONT CMD('C)INVALID
	CLR	@ARGC	 	;;RESET ARGC
*
*PROCESS	CMD	LINE	PARAMS
*
	MOV	@CMDBF,R4	;;GET CMD BUF VECTOR 
	MOV	R4,@SOB	;-->DOS CMD LINE
ENDLP	INC	R4	 
	CB	*R4,@CR	;
	JNE	ENDLP		;;NOT END OF LINE
SOBCK1	XOP	@GTSOB,0	;RET IF SOB<PTR
	DEC	R4	; 
	CB	*R4,@SPACE	;;SPACE
	JEQ	SOBCK1		;;YES
	CLR	R1	;
	INC	R4	;
	MOVB	R1,*R4	;ZER0 FOLLOWING BYTE
	DEC	R4	
DECR2	XOP	@GTSOB,0	 ;;RET ONLY IF SOB<PTR
	DEC	R4	
	CB	*R4,@SPACE		;;SPACE ?
	JNE	CKRIN	;NO
	INC	R4	
	XOP	R4,2	;NEXT ARGV PTR
	DEC	R4	
	INC	@ARGC	;BUMP ARGC 
	JMP	SOBCK1	
CKRIN	CB	*R4,@LPNT	;"<"?
	JEQ	RIN	;YES
	CB	*R4,@RPNT	;">"?
	JEQ	ROUT	;YES
	XOP	@GTSOB,0	 ;RET IF SOB<PTR
	JMP	DECR2	
;
;REDIR	STDIN
;
RIN	LI	R2,RD	
	JMP	RDIR	
;
;--REDIR STDOUT
;
ROUT	LI	R2,WRT	
;
;--REDIRECT	ROUTINE
;
RDIR	XOP	R4,2	;SAVE CMD LINE PTR
	MOV	R2,R1	;FETCH RD/WRT FLAG
	DEC	R1	;CONVERT TO STDIN/STDOUT FD
	XOP	@LOCFDB,0	;R4=FDB VECTOR(CAN'T FAIL)
	MOV	R4,@FDBVTMP	 ;<--
	XOP	R4,3	 ;;FETCH CMD LINE PTR
	XOP	R4,2	 	;;SAVE IT AGAIN
	INCT	R4	
	MOVB	*R4,R1	 ;LOAD 2ND BYTE
	DEC	R4	 ;R4-->1ST BYTE
	MOVB	R1,R1	;END OF ARGUMENT?
	JNE	RFILE	;NOT A SINGLE CHAR TOKEN
	MOVB	*R4,R1	
	SRL	R1,8	;RIGHT JUSTIFY
	CI	R1,>33	;LT 1ST AUX PORT
	JL	RFILE	;YES
	LI	R0,AMAX	
	AI	R0,50	
	C	R1,R0		;;GT LAST AUX PORT
	JH	RFILE	;YES
	AI	R1,>FFE2	 ;-30H
RFLAG	MOV	@FDBVTMP,R4	;
	MOV	R4,@FDBV	 
	MOV	R1,@FDEV(R4)	;;FLAG REDIRECTION <-- 
	XOP	R4,3	;RESTORE CMD LINE PTR
	JMP	SOBCK1	
;
;--FILE REDIRECTION
;
RFILE	XOP	@RFD,2	 	;;PUSH REDIR FD
	XOP	R4,2	 	;;PUSH R4->NAME
	XOP	R2,2	 	;;PUSH R2=OPENMODE
	CLR	R4	 	;;R4=SIZE,TYPE,TDI
	XOP	R4,2
	XOP	R4,2
	XOP	R4,2
	CALL	@CCOPEN		;OPEN REDIR FILE<-
	LI	R1,6
RFILE0	XOP	R2,3
	DEC	R1	
	JNE	RFILE0		;;POP 6 PARAMS
	MOV	R4,R4	 	;;SUCCESSFUL?
	JEQ	RFILE2	 	;;YES
	LI	R3,'R	' 	;;O/P "R"
	B	@ABORT
RFILE2	MOV	@RFD,R1	 	;;R1=REDIR FD
	DEC	@RFD	 	;;DECR FOR NEXT REDIR
	JMP	RFLAG
GTSOB	C	R4,@SOB	 	;;R4=PTR
	JLE	GTSOB0		;;RET IF PTR>SOB
	XOP	R0,1
GTSOB0	XOP	R2,3	 	;;WASTE RET ADDR
	DEC	R4	 	;;IS THIS SMALL-SHELL TALKING?
	MOVB	*R4,R1
	JNE	SKPA		;NO-IGNORE "GO"OR"JP"
	INC	R4
	XOP	R4,2	 	;;NEXT ARGV PTR
	DEC	R4
	INC	@ARGC	
SKPA	XOP	@ARGC,2		 ;PUSH ARGC
	MOV	R10,R4		;R4=SP
	INCT	R4	
	XOP	R4,2		 ;PUSH ARGV PTR
	LI	R4,EXIT	   
	XOP	R4,2		;PUSH EXIT ADDR FOR END OF CALL PROG 
	MOV	@BOJRET,R4	 ;;GET RETURN ADDR 
	B	*R4	
;
;
EXIT	CLR	R4	
	XOP	R4,2	
	XOP	R4,2	
;
;----CCEXIT(ERRCODE)
;
CCEXIT	XOP	R4,3	 ;WASTE RET ADDR
	XOP	R4,3	;ERROR CODE ? 
	MOV	R4,@TEMP	
	JEQ	EXIT0	;NO
	MOV	R4,R3	;CODE TO O/P IN RMB
	SWPB	R3	;
ABORT	LI	R2,COUT	;STD OUT=0
	XOP	@BDOS,0	;
	LI	R2,COUT	
	LI	R3,'?	' ;
	XOP	@BDOS,0	;
	LI	R3,>0D00	;CR 
	LI	R2,COUT	
	XOP	@BDOS,0	;
EXIT0	LI	R4,AMAX	;
	AI	R4,3	;1ST FILE FD
EXIT1	XOP	R4,2	
	XOP	@CCCLOSE,0	 ;;CLOSE IT IF OPEN
	MOV	@FDBV,R5	;;GET FDB VECTOR 
	CLR	@FFCB(R5)	;ZERO FCB ADDR 
	XOP	R3,3	
	XOP	R3,2	
	LI	R4,AMAX	
	AI	R4,FMAX	
	INCT	R4	;LAST FILE FD
	C	R3,R4	;DONE?
	JHE	EXIT2	;YES 
	XOP	R4,3	
	INC	R4	
	JMP	EXIT1	
EXIT2	MOV	@TEMP,R4	GET RET CODE
	SETO	R1	;TELL SHELL A VM PROG ENDED
	B	@SHELL	;;BACK TO SHELL
;
;--NORMAL	RETURN	TO	USER PROGRAM
;
DONE	CLR	R4	
	XOP	R0,1	
;
;----ERROR	RETURNS
;
ERR2	XOP	R2,3	
ERR1	XOP	R2,3	
ERR	LI	R4,-2
	XOP	R0,1	
;
;
;----BLOCK MOVE
;	R3=SOURCE
;	R4=DEST
;	R2=LENGTH
;
BMOVE	MOVB	*R3+,*R4+	
	DEC	R2	
	JNE	BMOVE	
	XOP	R0,1	
;
;----GET CALL PARMS FORM STACK
;	R3=DEST	ADDR
;	R2=#OF	WORDS	TO FETCH
*
GETP	MOV	R10,R4	;GET SP 
	AI	R4,4	 	;;TWO CALLS DEEP
GETP1	MOV	*R4+,*R3+	;
	DEC	R2	;1 WORD/TIME 
	JNE	GETP1	
	XOP	R0,1	
;
;---FIND FDB &FCB ENTRIES
;
FINDF	MOV	@CPFD,R1	;LOAD FD
	MOV	R1,R5	;SAVE IN R5
	XOP	@LOCFDB,0	;R4=ORIGINAL FDB VECTOR
	CI	R5,2	;REDIRECTABLE?
	JH	FNDF1	;NO
	MOV	@FDEV(R4),R1	;R1=DEVICE #
	JEQ	FNDF1	;NOT REDIRECTABLE
	XOP	@LOCFDB,0	;R4=REDIR FDB VECTOR
FNDF1	MOV	R4,@FDBV	;SAVE FDB VECTOR
	MOV	R4,R5	
	MOV	@FFCB(R5),R4	;;SAVE FCB VECTOR
	MOV	R4,@FCBV	
	XOP	R0,1	;
;
;----LOCATE FDB	ENTRY (R1=FD)
;
LOCFDB	LI	R0,AMAX	
	AI	R0,FMAX	
	AI	R0,3	 ;R0=AMAX+FMAX+3
	C	R1,R0	;OUT OF RANGE?
	JHE	LOCERR	;YES 
	LI	R3,6	;6 BYTES/FDB ENTRY
	MPY	R1,R3	;R4=FD*6
	AI	R4,FDB	
	XOP	R0,1	
LOCERR	B	@ERR2	 
;
;----FILL BUFFER,BUMP CBF,ZER0	NBB&CHG
;
FILL	XOP	@UBUF,0	 
	XOP	@ZNBB,0	
	LI	R2,RDRND		;;READ RECORD 
	XOP	@BDOS,0	 
	CI	R1,MINUS1		;;GOOD RESULT 
	JNE	FILL0	 	;;YES
	B	@ERR1	
FILL0	XOP	R0,1	
;
;	RETURN.IF.CHANGE.FLAG.ZERO
;	FLUSH.BUFFER,BUMP CBF,ZER0 NBB&CHG
;	PAD NEW BUFFER
;
BFLUSH	MOV	@FCBV,R4	 
	MOV	@CHG(R4),R1	;;CHG ZZERO ? 
	JNE	BFLUSH0	;NO
	XOP	R0,1	;YES
BFLUSH0	LI	R2,WRRND	;;
	MOV	R2,@CMD		;;
	XOP	@DSKIO,0	;; 
BF0A	XOP	@UBUF,0	 ;ADVANCE TO NEXT BUFFER(UPDATE)
*
*----INIT	BUFFER
*
IBUF	MOV	@FCBV,R3	
	MOV	@BSZ(R3),R2	
	AI	R3,BUF	 	;;->BUF
	LI	R1,BPAD	 	;;PAD BYTE
IBUF1	MOVB	R1,*R3+		;;PAD IT
	DEC	R2	
	JNE	IBUF1	
*
*-----ZERO	NBB
*
ZNBB	MOV	@FCBV,R3	 
	CLR	@NBB(R3)	;;ZERO NBB & SET FLAG 
	MOV	R2,R2		;;
	XOP	R0,1	;BUFFER FITS
*
*---UPDATE	BUFFER	CONTROLS
*
*
UBUF	MOV	@FCBV,R3	
	CLR	@CHG(R3)	 ;;CLEAR CHANGE FLAG
	INC	@CBF(R3)		;;BUMP CBF TO NEXT TRK/SEC
	XOP	R0,1	
*
*----SET	UP	DISK	IO PARMS
*
DSKIO	MOV	@SBS(R4),R3	 ;;USE THIS BUFFER
	LI	R2,SETDMA
	CALL	@BDOS
	MOV	@DRV(R4),R3
	LI	R2,SELDSK
	CALL	@BDOS
	MOV	@CMD,R2	 	;;ASSUME CMD HAS FUNCTION #
	CALL	@BDOS
	MOV	R1,R1	 	;;ERROR?
	JEQ	DSKIO1	 	;;NO
	B	@ERR2	 	;;YES
DSKIO1	RET
*
*TEMP	CDSZ
*
CDSZ	NOP	
	XOP	R0,1	
*
*
*SET	NEW	CBF&NBB	VALUE&ZERO CHG
*
NBUF	MOV	@FCBV,R4	 
	MOV	@NCBF,@CBF(R4)	 ;;NEW CBF
	MOV	@NNBB,@NBB(R4)	 ;;NEW NBB
	CLR	@CHG(R4)	 ;;ZERO CHG 
	XOP	R0,1	
*
*-TRAP	CALL	TO	CIN
*
CINTRAP	MOV	R4,@ARGC	
	MOV	R1,R1	 ;;CONSOLE I/P ?
	JNE	CINTRAP2	 	;;NO-LET IT GO THEN 
CINTRAP1	LI	R4,CINTRAP3	 ;YES - SET UP RET HERE 
	XOP	R4,2	
CINTRAP2	XOP	@CINV,2		;;PUSH VECTOR 
	MOV	@ARGC,R4	;;RESTORE R4 
	XOP	R0,1		;;CALL CIN *** 
CINTRAP3	CI	R1,>1200	 ;;CTL-R?
	JEQ	UPR	 	;;YES
CINTRAP4	MOV	@ARGC,R4	 ;;RESTORE R4
	XOP	R0,1	 	;;RETURNBYTE TO CALLER
UPR	LI	R1,>1200	 
	MOV	@SAVSP,R4	 
	JEQ	CINTRAP4	 ;;REENTRE CMD INVALID-RET ^R TO CALLER
	MOV	@CMDBF,R4	 ;;WILL SMALL-SHELL ALLOW IT?
	DECT	R4	
	LI	R1,>1200	 
	MOVB	*R4,R0	 
	JEQ	CINTRAP4	 ;;NO
	B	@REENTER	
*
*
*CCPOLL(FLAG)
*
*
CCPOLL	MOV	R10,R4	;GET SP 
	INCT	R4	;BUMP PAST RET ADDR 
	MOV	*R4,R1	;GET FLAG
	CI	R1,2	;RETURN CONSOLE STATUS?
	JNE	POLL1	;N0
	XOP	@CONTC,0	;LOOK FOR CTL-C 
	CLR	R4	
	JNC	POLL0	;NO CHAR,SO RETURN ZERO 
	JEQ	POLL2	;CNTL-C MATCH 
	MOV	R1,R4	;NOT CNTL-C,SO RET CHAR
POLL0	XOP	R0,1	
POLL2	MOV	@UPCSW,R0	;LOOKING FOR CNTL-C'S?
	JEQ	POLL0	;NO-SO RETURN CNTL-C 
	CLR	R1	
	CLR	R4	
	JMP	CCHALT	;YES SO RET ZERO WHEN RESUMED
*
POLL1	MOV	R1,UPCSW	;FLAG 0? 
	JEQ	POLL0	;YES
	XOP	@CONTC,0	;
	JNC	POLL0	;NO CONSOLE INPUT
	JEQ	CCHALT	;CNTL-C FROM CONSOLE
	CB	R1,@SPACE	;SPACE? 
	JNE	POLL0	;NO SO CONTINUE
	CLR	R1	;PAUSE TILL NEXT CHAR FROM CONSOLE
	XOP	@CIN,0	
	CI	R1,>0300	 ;CTL-C?
	JNE	POLL0	;NO,CONTINUE
*
*
*----CCHALT()
*
*		SAVE	CONTEXT AND RET TO SHELL
*
CCHALT	STST	R15	;SAVE STATUS
	XOP	R15,2	;PUSH IT
	XOP	R1,2	;SAVE PRIMARY REGS
	XOP	R2,2	
	XOP	R3,2	
	XOP	R4,2	
	MOV	R10,@SAVSP	;SAVE SP
	MOV	R9,@SAVSL	 ;;SAVE STACK LIMIT
	SETO	R4	;KILL SHELL PROC,IF IN ONE
	B	@SHELL	 
*
REENTER	MOV	@SAVSP,R10	;RESTORE SP
	CLR	@SAVSP	;FLAG CONT CMD INVALID
	MOV	@SAVSL,R9	
	XOP	R4,3	
	XOP	R3,3	
	XOP	R2,3	
	XOP	R1,3	
	XOP	R15,3	;ST
	XOP	R14,3	;PC
	STWP	R13	;WP
	RTWP		;CONT WITH CONTEXT
*
*CCOPEN(FD,NAME,MODE,SIZE,TYPE,TDI)
*
CCOPEN	LI	R3,CPTDI	;FETCH CALL PARMS
	LI	R2,6	;NO OF WORDS 
	XOP	@GETP,0	
	XOP	@FINDF,0	;SET FDBV & FCBV
	MOV	@FDBV,R5	 ;CHECK MODE
	MOV	@FMODE(R5),R1	 ;;OPEN ? 
	JEQ	CCOPEN1	;NO 
	B	@ERR	;YES
CCOPEN1	MOV	@FCBV,R0	;FCB ALREADY ALLOCATED ?
	JNE	OPN0	;YES
	LI	R4,FCBSZ	
	XOP	R4,2	;PUSH MEM FOR NEW FCB
	XOP	@CCALLOC,0	;
	XOP	R2,3	
	MOV	R4,@FCBV	
	MOV	R4,@FFCB(R5)	; 
OPN0	MOV	@CPMODE,R0	
	JNE	OPN0A	 
	B	@DONE	;ALLOC FCB ONLY
*
*FLUSH.FCB
*
OPN0A	LI	R1,BUF	
	MOV	@FCBV,R4	 ;
	MOV	R4,R3	
OPN0B	CLR	*R3+	
	DECT	R1	
	JNE	OPN0B	
	LI	R1,1	;SET DEFAULT DRIVE #1
	MOV	R1,@DRV(R4)	 
*
*INITIALISE.BUFFER.LIMITS
*
	MOV	R4,R5	 	;;COPY FCB BASE
	AI	R4,BUF	 	;;POINT TO BUFFER AREA
	MOV	R4,@SBS(R5)	 ;;COPY TO SBS
	AI	R4,BLKSZ	 ;;END OF BUFFER
	MOV	R4,@SBE(R5)	;
*
*VALIDATE	FILE	NAME
*
	MOV	@FCBV,R3	;R3->NAME IN FCB 
	MOV	@CPNAME,R4	;R4->NAME
	LI	R2,10	;CHARS TO SEARCH
	CLR	R1	
OPN1	MOVB	*R4+,R1	;LOAD NXT BYTE
	JEQ	OPN3	;NULL !
	CI	R1,>2C00	;COMMA ?
	JEQ	OPN2	;YES
	CI	R1,>2000	;SPACE ?
	JEQ	OPN1A		;;YES 
	MOVB	R1,*R3+	;STORE IN FCB NAME
	DEC	R2	
	JNE	OPN1	  ;NOT TRAILING BYTE YET
OPN1A	B	@OPNERR	 ;NINTH BYTE MUST BE NULL OR COMMA
*
OPN2	MOVB	*R4+,R1	;DRIVE =1 THRU 8 ?
	SRL	R1,8	 	;;PLACE IN MSB
	CI	R1,>31	;1
	JL	OPN1A		;;N0
	CI	R1,>32	;2 
	JH	OPN1A	;HIGH
	AI	R1,>FFE2	;-30
	MOV	@FCBV,R3		;;GET FCB PNTR 
	MOV	R1,@DRV(R3)	;;STORE IN FCB OVER DEFAULT 
	MOVB	*R4,R1	;NEXT BYTE NULL ?
	JNE	OPN1A	;NO
*
*-CALL	DLOOK	TO	FIND FILE
*
*
*
OPN3	LI	R1,>2000	;FORCE TRAIL SPACES
OPN4	MOVB	R1,*R3+	;
	DEC	R2	
	JNE	OPN4	
	MOV	@FCBV,R4	;R4->FILENAME,SP,SP..
	LI	R2,SELDSK	;;
	MOV	@DRV(R4),R3	 
	XOP	@BDOS,0	
	LI	R2,DLOOK	
	XOP	@BDOS,0	;LOOK FOR IT
	CI	R1,MINUS1	;;IS IT THERE ? 
	JEQ	NEW		;;NO
*
*FDE.COPIED.TO.FCB
*
OLD	MOV	@FCBV,R4	 
	LI	R0,BLKSZ	 ;;USE STANDARD SIZE
	MOV	R0,@BSZ(R4)	
	MOV	@CPMODE,R1	;MODE CHECK
	CI	R1,RD	 	;;RD ?
	JEQ	OLD2	 ;YES
	CI	R1,RDWRT	;RDWRT ?
	JEQ	OLD2	 ;YES
	CI	R1,WRT	 ;WRT ?
	JEQ	OLD2		;;YES 
OLDERR	B	@OPNERR	 ;NO
*
*MODE=RD,RD/WRT.OR.WRT
*
OLD2	LI	R2,OPENF	;;OPEN THE FILE
	XOP	@BDOS,0	
	MOV	R1,R1		;;ERROR ?
	JLT	OPNERR	 	;;YES
	MOV	@FSZ(R4),R0	
	JEQ	OPNERR	 	;;FAIL IF ZERO LENGTH FILE
	B	@OPNB	
*
*
NEW	MOV	@FCBV,R4		;;FCB VECTOR
	MOV	@CPTYPE,@FTY(R4)	 ;;STORE TYPE IN FCB
	CLR	@FSZ(R4)	 ;;FILE SIZE
	LI	R0,BLKSZ	 ;;USE STANDARD
	MOV	R0,@BSZ(R4)	 ;;SET BUFFER SIZE
	MOV	@CPMODE,R0	 
	CI	R0,WRT	;WRT ?
	JNE	OPNERR	;NO 
	LI	R2,MAKFIL	 ;;CREATE NEW FILE
	XOP	@BDOS,0	
	CI	R1,MINUS1	
	JEQ	OPNERR	
*
OPNB	MOV	@FCBV,R4	 
	CLR	@CBF(R4)	;;CLEAR CBF
	XOP	@IBUF,0	 ;INIT NEW BUFFER,ZERO NBB
	CLR	@CHG(R4)	 ;;CHG=0<-- 
	MOV	@FDBV,R5	
	MOV	@CPMODE,@FMODE(R5)	;SET MODE IN FDB
	MOV	@CPMODE,R0	
	CI	R0,WRT	;WRT ?
	JEQ	OPNC	;YES
	B	@SEEK4	;NO--SEEK 1ST BYTE(RD OR RD/WRT)
OPNC	B	@DONE	 ;EXIT
OPNERR	XOP	@FCBFREE,0	 ;DEALLOCATE FCB
	B	@ERR	
*
*-TRY	TO	DEALLOCATE	THE CURRENT FCB
*
FCBFREE	XOP	@FCBV,2	;PUSH FCBV
	LI	R4,FCBSZ	;
	XOP	R4,2	;PUSH SIZE
	XOP	@CCFREE,0	;R4=0 IF MEM RELEASED
	XOP	R2,3	;ELSE ORIG FCB VALUE
	XOP	R2,3	
	MOV	@FDBV,R5	 ;;CURRENT FDB
	MOV	R4,@FFCB(R5)	 ;;ZERO FCB PNTR OR LEAVE UNCHANGED
	XOP	R0,1	;
*
*
*----CCCLOSE(FD)
*
CCCLOSE	LI	R3,CPFD	 ;FETCH CALL PARM
	LI	R2,1	
	XOP	@GETP,0	
	XOP	@FINDF,0	 ;SET FDBV & FCBV VECTORS
	MOV	R4,R0	;R4=FCBV=0?(I/O PORT)
	JEQ	CLSERR	;;YES 
	MOV	@FDBV,R4	 
	MOV	@FMODE(R4),R1	;;OPEN 
	JEQ	CLSERR	 ;NO
	XOP	@BFLUSH,0	;FLUSH THE BUFFER IF NECESSARY
	MOV	@FSZ(R4),R0	 ;;FILE SIZE ZERO?
	JEQ	CLSE2	 	;;YES
	MOV	@CBF(R4),@FSZ(R4)	 ;;SET FILE SIZE
	MOV	@DRV(R4),R3	 ;;
	LI	R2,SELDSK	 ;;
	XOP	@BDOS,0	 	;;
	LI	R2,CLOSEF	;;TRY TO CLOSE
	XOP	@BDOS,0	  
	MOV	R1,R1		;;SUCCESS ?
	JLT	CLSERR		;;NO
CLSE2	XOP	@FCBFREE,0	 ;TRY TO DEALLOCATE FCB
	MOV	@FDBV,R5	 
	CLR	@FMODE(R5)	 ;;CLOSE FILE <--- 
	B	@DONE	
CLSERR	B	@ERR	 
*
*---CCDELIM(BYTE)
*
CCDELIM	MOV	R10,R4	;GET SP
	INCT	R4	
	MOVB	*R4,@DBYTE	
	LI	R1,2	
	MOV	R1,@DFLAG	;EACH CCREAD SHIFTS THIS
	XOP	R0,1	;RETURNS NOTHING
*******************************	
*
*---CCREAD(FD,REC,RECSZ)
*
*******************************
*
CCREAD	LI	R3,CPRECSZ	;FETCH CALL PARMS
	LI	R2,3	 
	XOP	@GETP,0	
	XOP	@FINDF,0	;SET FDBV & FCBV VECTORS
*SHIFT	DELIMITER	FLAG
	MOV	@DFLAG,R1	
	SRL	R1,1	
	MOV	R1,@DFLAG	
*
	MOV	@FDBV,R5	;;OPEN FOR RD OR RD/WRT
	MOV	@FMODE(R5),R1	 
	CI	R1,RD	 
	JEQ	RD1	 ;YES
	CI	R1,RDWRT	
	JEQ	RD1	;YES 
	B	@ERR	 ;NO
RD1	CLR	R4	 ;BYTE INDEX=0
	MOV	R4,@TEMP	;SAVE AS TEMP
*
*LAST	BYTE	TRANSFERRED
*
RD2	MOV	@TEMP,R4	
	C	R4,@CPRECSZ	 ;CURR BYTE<BYTES TO TFR ? 
	JL	RD3	 	;;YES-NOT YET FINISHED 
	XOP	R0,1	;FINISHED--RETURN COUNT OF BYTES TRANS 
*
*GET	NEXT	BYTE
*
RD3	MOV	@FCBV,R4	
	JNE	RD5	 ;FILE INPUT
*
RD3A	MOV	@FDBV,R5	 
	MOV	@FDEV(R5),R1	;I/O PORT -- WHICH PORT
	LI	R2,CIN	 	;;I/P CHAR
	XOP	@BDOS,0	;<---
	MOV	@UPCSW,R0	 ;HONOUR CTL-C INT ?
	JEQ	RD4	 ;NO
	CI	R1,>0300	;CTL-C ?
	JNE	RD4	 ;NO
	MOV	@FDEV(R5),R0	;;FROM CONSOLE ? 
	JNE	RD4	 ;NO
	XOP	@CCHALT,0	 ;YES
	JMP	RD3A	 
*
*MOVE	BYTE(R1)	TO	USER AREA
*
RD4	MOV	@TEMP,R4	 ;R4=BYTE INDEX
	A	@CPREC,R4	;R4=CUR BYTE IN USER AREA
	MOVB	R1,*R4	 ;<--
	INC	@TEMP		;;BUMP INDEX
*
*TEST	FOR	EARLY	TERMINATION ON BYTE MATCH
*
	MOV	@DFLAG,R0	
	JEQ	RD2	
	CB	R1,@DBYTE	 ;EQUAL ?
	JNE	RD2	;NO 
	XOP	R0,1	 ;YES - RET BYTES ACTUALLY TRANSFERRED
*
*ANY	MORE	BYTES	IN BUFFER
*
RD5	MOV	@FCBV,R5	 
	C	@NBB(R5),@BSZ(R5)	;;NBB<BSZ ? 
	JHE	RD6	 	;;NO
*
*FETCH	NEXT	BYTE	FROM BUFFER
*
RD5A	MOV	@FCBV,R5	;; 
	MOV	R5,R4	 	;;
	AI	R4,BUF	 
	A	@NBB(R5),R4	 ;;R4->NEXT BYTE IN BUFFER 
	MOVB	*R4,R1	 	;;<--
	INC	@NBB(R5)	 ;;BUMP NBB 
	JMP	RD4	 ;GO PUT BYTE IN USER AREA
RD6	MOV	@CBF(R5),R4	 
	INC	R4	 ;R4=NEW CBF FOR SEEK
	C	@FSZ(R5),R4	 ;;FSZ>CBF+1 ?
	JH	RD7	 	;;YES
	MOV	@TEMP,R4	;;NO
	XOP	R0,1	
*
*SEEK	NEXT	SECTOR
*
RD7	CLR	R3	 	;;NEW NBB 
	XOP	@RWSEEK,0	 ;;<--- 
	MOV	R4,R0	 	;;SEEK OK? 
	JNE	RDERR	 	;;NO
	CLR	R3	 	;;R3=0=NBB 
	JMP	RD5A	 
RDERR	B	@ERR	
*******************************
*
*CCWRITE(FD,REC,RECSZ)
*
*******************************
*
CCWRITE	LI	R3,CPRECSZ	 ;FETCH CALL PARAMS
	LI	R2,3	
	XOP	@GETP,0	
	XOP	@FINDF,0	;;SET FDBV & FCBV VECTORS 
	MOV	@FDBV,R5	 
	MOV	@FMODE(R5),R1	;;OPEN FOR RD/WRT? 
	CI	R1,WRT	
	JEQ	WRT1	 ;YES
	CI	R1,RDWRT	
	JEQ	WRT1	;YES
	B	@ERR	;NO GOOD
*
WRT1	CLR	R4	
	MOV	R4,@TEMP	;BYTE INDEX=0
*
WRT2	MOV	@TEMP,R4	
	C	R4,@CPRECSZ		;;CURRENT BYTE<BYTES TO TFR ? 
	JL	WRT3	 ;;YES-NOT YET FINISHED
	XOP	R0,1	 	;;OF BYTES TRANSFERRED
*
*TRANSFER	NEXT	BYTE
*
WRT3	MOV	@CPREC,R4	 ;;R4->USER DATA ADDR
	A	@TEMP,R4	 ;;R4->CUR BYTE OF USER DATA
	MOVB	*R4,R3	 ;R3=DATA BYTE
	MOV	@FCBV,R0	
	JNE	WRT5	 	;;FILE O/P
*
	MOV	@FDBV,R5	 
	MOV	@FDEV(R5),R1	;;I/O PORT O/P--WHICH ONE? 
	LI	R2,COUT	;DATA BYTE IN R3 
	XOP	@BDOS,0	 	;;O/P CHAR
*
*BUMP	BYTE	INDEX	& LOOP BACK
*
WRT4	INC	@TEMP	 	;;GET CURRENT BYTE IN R4
	JMP	WRT2	
*
*WILL	BYTE	FIT	IN CUR BUFFER ?
*
WRT5	MOVB	R3,@DATA	 
	MOV	@FCBV,R4	 
	C	@NBB(R4),@BSZ(R4)	 ;;NBB<BSZ? 
	JL	WRT10	 	;;YES
*
*NO--THEN	SEEK	OR	INIT NEXT BUFFER
*
	MOV	@FDBV,R5	 
	MOV	@FMODE(R5),R1	 ;;WRITE MODE ? 
	CI	R1,WRT	
	JEQ	WRT9	 	;;YES
	MOV	R4,R5	 
	MOV	@CBF(R5),R4	 ;;NO-MUST BE RD/WRT THEN
	INC	R4	 	;;NEW CBF
	CLR	R3	 	;;NEW NBB
	XOP	@RWSEEK,0	 ;;<---
	MOV	R4,R0	 	;;DID SEEK FAIL ?
	JNE	WRT9A	 	;;YES - EOF
	JMP	WRT10	 	;;NO--GOOD
*
*FLUSH	&	PAD	THE BUFFER,BUMP CBF
*
WRT9	XOP	@BFLUSH,0	
	JEQ	WRT10	 	;;NEXT BUFFER FITS
*
WRT9A	MOV	@TEMP,R4	 ;;NO ROOM SO RETURN
	XOP	R0,1	 	;;COUNT OF BYTES TRANS
*
*STUFF	THIS	BYTE	IN THE BUFFER
*
WRT10	MOV	@FCBV,R4	 
	SETO	@CHG(R4)	;CHANGE-FLAG
	MOV	R4,R3	 
	AI	R3,BUF	;R3->BUFF 
	A	@NBB(R4),R3	;;R3->NBB 
	MOVB	@DATA,*R3	;;STUFF DATA IN BUFFER 
	INC	@NBB(R4)	 ;;UPDATE NBB 
	JMP	WRT4		;;
*
*CCSEEK(FD,DISP,BASE)
*
CCSEEK	LI	R3,CPBASE	 ;;FETCH CALL PARMS
	LI	R2,4		;;DISP IS 32 BITS 
	XOP	@GETP,0	
	XOP	@FINDF,0	 ;SET FDBV&FCBV VECTORS
	MOV	R4,R0	 	;;DISK FILE ?
	JEQ	CCSEEK0	
	MOV	@FDBV,R5	 
	MOV	@FMODE(R5),R0	;OPEN ?
	JEQ	CCSEEK0	 	;;N0
	CI	R0,WRT	 	;;0PEN FOR WRT ?
	JNE	CCSEEK1		;;NO
CCSEEK0	B	@ERR	
*
*CALCULATE	NEW	CBF	& NBB
*
CCSEEK1	MOV	@CPBASE,R4	
	JNE	SEEK1C	
	MOV	@FCBV,R4	 
	MOV	@BSZ(R4),R0	 ;;R0=BSZ 
	MOV	@CBF(R4),R3	 ;;R3=CBF 
	MPY	R3,R0	 	;;R1=CBF*BSZ 
	A	@NBB(R4),R1	;;R1=(CBF*BSZ)+NBB 
	JNC	SEEK1A	 	;;IF CARRY BUMP R3
	INC	R0	 	;;R0=MSB
*
SEEK1A	A	@CPDISP,R1	 ;
	JNC	SEEK1D	
	INC	R0	 	;;R0,R1=((CBF*BSZ)+NBB)+CPDISP
	JMP	SEEK1D	
*
SEEK1C	MOV	@CPBASE,R0	 ;;
	MOV	@CPDISP,R3	
	MPY	R3,R0	 	;;R0,R1=CPDISP*CPBASE
SEEK1D	MOV	@FCBV,R4	 
	MOV	@BSZ(R4),R2	
*
*DIV--(D,D+1)/S	RES->QUOT	IN	D
*REM	IN	D+1
*
	DIV	R2,R0	 ;(R0,R1)/R2 
	MOV	R0,R4	 	;;R4->R3 
	MOV	R1,R3	 
*
*<<<ENTRY	POINT	FROM	READ&WRITE>>>
*
RWSEEK	MOV	R4,@NCBF	 ;;SAVE NEW CBF
	MOV	R3,@NNBB	 ;;SAVE NEW NBB(REM)
	MOV	@FCBV,R4	 
	C	@CBF(R4),@NCBF	 ;;NEW CBF=OLD CBF ? 
	JEQ	SEEK5	YES,SKIP FLUSH & FILL
*
*FLUSH	OLD	BUFFER
*
	XOP	@BFLUSH,0	 ;<---
*
	MOV	@FCBV,R4	 
	MOV	@FSZ(R4),R0	 ;;FSZ=0? 
	JNE	SEEK2	 ;;NO
	MOV	@NCBF,R4	 ;;NEW CBF<DRIVE SIZE
*	XOP	@CDSZ,0	
*	JNC	SEEK1	 	;;NO-TOO BAD
	JMP	SEEK3	 ;YES
SEEK1	B	@ERR	
SEEK2	MOV	@FCBV,R4	 
	C	@FSZ(R4),@NCBF	;;NCBF<FSZ 
	JHE	SEEK3	
	B	@ERR	 	;;NO TOO BAD 
*
*READ	NEW	BUFFER
*
SEEK3	XOP	@NBUF,0	
*
SEEK4	LI	R2,RDRND	 ;;
	MOV	R2,@CMD		;; 
	XOP	R3,2	 ;;MAKES JMP TO ERR2 WORK IN DSKIO 
	XOP	@DSKIO,0	; 
	XOP	R3,3		;;
	B	@DONE	
*
SEEK5	XOP	@NBUF,0	 	;;SET CBF,NBB AND CHG
	B	@DONE	
*
*---CCMODE(FD)
*
CCMODE	LI	R3,CPFD	
	LI	R2,1	
	XOP	@GETP,0	
	XOP	@FINDF,0	
	MOV	@FDBV,R5	 
	MOV	@FMODE(R5),R4	 
	SWPB	R4	 	;;SIGN EXTEND
	SRA	R4,8		;;CARRY MSB THRU
	XOP	R0,1	
*
*----CCFILE(FD)
*
CCFILE	LI	R3,CPFD	
	LI	R2,1	
	XOP	@GETP,0	
	XOP	@FINDF,0	 ;;R4=FCBV
	XOP	R0,1	
*
*----CCPURGE(NAME)
*
CCPURGE	LI	R3,CPNAME	
	LI	R2,1	
	XOP	@GETP,0	
	LI	R2,10		;;BYTES TO MOVE
	LI	R4,FDETMP	 ;;DEST PTR
	MOV	@CPNAME,R3	 ;;SOURCE PTR
PURGE1	MOVB	*R3+,R1		;;NULL ?
	JEQ	PURGE2	 	;;YES
	MOVB	R1,*R4+	 	;;TRANS NAME TO DEST
	DEC	R2	
	JNE	PURGE1	
	JMP	PURGE3	
PURGE2	MOVB	@SPACE,*R4+	;;TERMINAL SPACE FOR DLOOK
	DEC	R2	
	JNE	PURGE2	 	;;FILL WITH BLANKS
*
*
PURGE3	LI	R4,FDETMP	 ;;TEMP FCB PNTR 
	LI	R3,1		;;DEFAULT DRIVE 
	MOV	R3,@DRV(R4)	;;DEFAULT DRIVE
	LI	R2,SELDSK	;;
	XOP	@BDOS,0	 ;;
	LI	R2,ERAFIL	;;TRY TO ERASE THE FILE 
	XOP	@BDOS,0	
	MOV	R1,R1		;;SUCCESS ?
	JLT	PURGE4	 	;;NO
	B	@DONE	 	;;
PURGE4	B	@ERR	
*
*----CCFLUSH(FD)
*
CCFLUSH	LI	R3,CPFD	 	;;FETCH CALL PARM
	LI	R2,1	
	XOP	@GETP,0	
	XOP	@FINDF,0	 ;;SET FDBV&FCBV
	MOV	R4,R4	
	JEQ	CCFLUSH0	 ;;IGNORE IF NO FCB 
	MOV	@FDBV,R5	 
	MOV	@FMODE(R5),R0	 
	JEQ	CCFLUSH0	 ;;IGNORE IF CLOSED
	MOV	@FCBV,R4	 
	MOV	@CHG(R4),R0	 
	JEQ	CCFLUSH0	 ;;IGNORE IF NOT MODIFIED
	LI	R2,WRRND	;;
	MOV	R2,@CMD		;;
	XOP	R3,2	 	;;MAKES DSKIO WORK 
	XOP	@DSKIO,0	;; 
	XOP	R3,3		;;
	MOV	@FCBV,R4	 
	CLR	@CHG(R4)	 
CCFLUSH0	B	@DONE	;;ALL DONE
CCFL0A	B	@ERR1	
*
*-----CCALLOC(SIZE)
*
CCALLOC	MOV	R10,R4	 	;;GET SP
	INCT	R4	 	;;SP=SP+2
	MOV	*R4,R3	 	;;R3=MSIZE
	MOV	@FREEMEM,R4	 ;;OLD FREEMEM PTR
	MOV	R4,R2	 	;;COPY TO R2   
	A	R3,R2	 	;;R2=NEW FREE MEM PTR
	C	R2,R10	 	;;NEW PTR < SP ?
	JL	ALLOC1	 	;;YES-OK
ACLUE	LI	R3,>4100	 ;;"A" CLUE
	B	@ABORT	
ALLOC1	MOV	R2,@FREEMEM	 ;;UPDATE PTR
	MOV	R2,R9	  	;;COPY TO R9(STACK LIMIT)
	XOP	R0,1	
;
;---CCFREE(ADDR,SIZE)
;
CCFREE	LI	R3,CPSIZE	
	LI	R2,2	
	XOP	@GETP,0	
	MOV	@CPADDR,R4		;BLOCK TO FREE
	MOV	@CPSIZE,R3		;SIZE TO FREE
	MOV	R4,R5	
	A	R3,R5			;FREE ONLY IF LAST BLOCK ALLOCATED
	C	@FREEMEM,R5	
	JEQ	FREE1	 		;GOOD-NOT EMBEDDED
	RET		 		;NO-SO RETURN ORIGINAL BLOCK PTR
FREE1	C	R5,@EOP	 		;BLOCK PTR<END OF PROGRAM
	JH	FREE2	 		;NO
	LI	R3,'F'*256		;"F" CLUE
	B	@ABORT
FREE2	MOV	R4,@FREEMEM		;UPDATE FREE MEM PTR
	MOV	R4,R9	 		;COPY TO STACK LIMIT
	CLR	R4	
	RET
*
*----CCAVAIL()	
*
CCAVAIL	MOV	@FREEMEM,R3	 
	MOV	R10,R4		 	;GET SP
	C	R4,R3		 	;OVERFLOW ?
	JH	AVAIL0	 		;NO
	B	@ACLUE	 		;GIVE ERR CLUE
AVAIL0	S	R3,R4			;SP-EOP=R4
	RET
;
;
CC9997	B	@CCBOJ	
CC9998	NOP			;;JMP $+6 LOADS HERE
	NOP	
	NOP			;;NEXT MODULE IF ANY LOADS SATRTING HERE
	XOP	R3,2	
	LI	R3,CC9999	 
	B	@CC9997	 
CC9999	NOP	
;
;FREE	MEM	STARTS	HERE IF LAST MODULE
;LOADED	WITH	PROG
	END
