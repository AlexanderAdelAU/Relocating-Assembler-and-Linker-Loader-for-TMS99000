                        ;       Math48 Floating Point Package
                        ;       Version 1.1 Revision 1
                        ;       by Anders Hejlsberg
                        ;       2532 Bytes
                        ;       TMS9900/99000 VERSION BY ALEXANDER CAMERON JUNE 2020
                        ;		PARTS TAKEN FROM CFLOAT.C AS PART OF SMALLCPLUS
                        ;
                        ;
                        ;
                        ;Floating number format.
                        ;   ============================================================
                        ;
                        ;     A floating number is made by the three 16-bit registers BC, DE and HL
                        ;     (collectively called AC) or the corresponding alternative registers
                        ;     BC', DE' og HL' (collectively called AC').;
                        ;
                        ;     The five 8-bit registers B,C,D,E and H (Collectively called BCDEH) represent
                        ;     in the mentioned succession the number mantissa in binary representation.
                        ;     The binary decimal point is placed immediately in front of the B register.
                        ;     In this way, the bit 7 of B tell the number of halves (2^-1) in the number,
                        ;     bit 6 the number of quarters (2^-2) etc.
                        ;     The value of the mantissa may also be aprehended as the binary integer
                        ;     BCDEH divided by 2^40.;
                        ;
                        ;     The L register contain the number exponent, that is the number 2 must be
                        ;     raised to, to give the factor that the mantissa shall be multiplied by.
                        ;     The absolute value of the L register is the exponent plus
                        ;     128 (80H). If for example L has the value 83H the exponent will be 3.
                        ;     If L has the value 7DH the exponent is -3.
                        ;     If L is zero it tells that the whole number is zero. In this way the
                        ;     exponent may take any integer value between -127 (01H) and 127 (FFH).
                        ;
                        ;     Of this it is seen that the number in AC shall be comprehended in the
                        ;     following way.;
                        ;
                        ;         AC=(BCDEH/2^40)*2^(L-128)
                        ;
                        ;     Where BCDEH is a whole binary number.
                        ;
                        ;     As the exponent is the power that 2 shall be raised to, then it is given,
                        ;     that the value of AC is doubled if one is added to the exponent, and
                        ;     halved if one is subtracted from the exponent.
                        ;     Likewise it is given that the number in BCDEH is doubled if it is shifted
                        ;     one bit to the left and halved if it is shifted one bit to the right.
                        ;     One may therefore, theoretically speaking, shift BCDEH to right or
                        ;     left an arbitrary number of bits, as long as this number is added or
                        ;     subtracted from the exponent.
                        ;
                        ;     The above stated is exploited in every calculation to normalize
                        ;     the number in AC:
                        ;     The mantissa (BCDEH) is repeatedly shifted one bit left untill the
                        ;     most significant bit is set (bit 7 in B). Hereafter the number of shifts are
                        ;     subtracted from the exponent.
                        
                        ;     This normalizing is done for two reasons: firstly is is
                        ;     securing that the number has the maximum precision, as it
                        ;     leaves the most significant bits in the mantissa.
                        ;     Secondly it releases the most significant bit of the mantissa,
                        ;     as this bit will always be set in a normalized number. The most
                        ;     significant bit is in stead used as a sign indicator:
                        ;     If it is set then the number is negative. If it is zero then the number
                        ;     is positive. The absolute value of a number may thus be calculated
                        ;     by simply resetting the bit 7 in the B register.
                        ;
                        ;     The construction of a floating number is compiled to:
                        ;
                        ;         Reg. Bit    Meaning;
                        ;
                        ;          B    7     Sign. 0=Positive. 1=Negative.
                        ;          B   6-0    mantissa bit   38-32. Bit 39 always set.
                        ;          C   7-0    mantissa bit   31-24.
                        ;          D   7-0    mantissa bit   23-16.
                        ;          E   7-0    hantisse bit   15-8.
                        ;          H   7-0    hantisse bit   7-0.
                        ;          L   7-0    L=0: the number is Zero.
                        ;                     L>0: Exponent+128 (80H).;
                        ;
                        ;     If a floating point number is zero (ie. if the L register is zero)
                        ;     then it does'nt matter what is in the mantissa as long as the sign
                        ;     bit is zero.
                        ;
                        ;     Examples of floating point numbers (BCDEH and L in hexnotation):;
                        ;
                        ;      BCDEH       L   Value             Remarks;
                        ;
                        ;      0000000000  00  0                 L er nul.
                        ;      0000000000  81  1                 2^-1*2^1.
                        ;      0000000000  82  2                 2^-1*2^2.
                        ;      8000000000  82  -2                Negative as bit 7 in B is set.
                        ;      7000000000  84  15                (2^-1+2^-2+2^-3+2^-4)*2^4.
                        ;      4800000000  87  100               (2^-1+2^-2+2^-5)*2^7.
                        ;      4CCCCCCCCD  7D  0.1               Not final
                        ;      0000000000  01  2.938735877E-39   Smallest possible number.
                        ;      7FFFFFFFFF  FF  1.701411835E+38   Largest possible number.
                        ;     ===================================================================
                        ;
                        ;
                        ;     For the 9900 construction of a floating number is compiled to:
                        ;
                        ;         Reg. Bit    Meaning;
                        ;
                        ;       R5 MSB 7      Sign. 0=Positive. 1=Negative.
                        ;       R5 MSB 6-0    mantissa bit   38-32. Bit 39 always set.
                        ;       R5 LSB 7-0    mantissa bit   31-24.
                        ;       R6 MSB 7-0    mantissa bit   23-16.
                        ;       R6 LSB 7-0    mantisse bit   15-8.
                        ;       R7 MSB 7-0    mantisse bit   7-0.
                        ;       R7 LSB 7-0    L=0: the number is Zero.
                        ;					  L>0: Exponent+128 (80H).;
                        ;
                        
  0000                  R0			EQU 	0		;Free use
  0001                  R1			EQU 	1		; Can be used but in some operations they are AC' prime registers
  0002                  R2			EQU 	2		; Can be used but in some operations they are AC' prime registers
  0003                  R3			EQU 	3		; Can be used but in some operations they are AC' prime registers
  0004                  R4			EQU 	4		;Free use
  0005                  R5			EQU 	5
  0006                  R6			EQU 	6
  0007                  R7			EQU 	7
  0008                  R8			EQU 	8		;Free use
  0001                  R5'			EQU		R1		;Prime register
  0002                  R6'			EQU		R2		;Prime register
  0003                  R7'			EQU		R3		;Prime register
  0009                  R9			EQU		9
  000D                  WP			EQU 	13		;WORKSAPCE REGISTER
  000F                  ST			EQU		15		;STATUS REGISTER
  000A                  SP			EQU 	10		;STACK POINTER
  000B                  R11			EQU 	11
                        
                        			DXOP 	CALL,6
                        			DXOP 	RET,7
                        			DXOP 	PUSH,8
                        			DXOP 	POP,9
                        			DXOP	WHEX,10
                        
  0080                  SIGN:   	EQU  	80H
  0080                  EXPN:   	EQU  	80H
  1000                  CBIT:		EQU		1000H
  4000                  AGT:		EQU		4000H
  8000                  LGT:		EQU		8000H
  0800                  OVFLO:		EQU		0800H
  000A                  RES_BYTE: 	EQU		2*R5			;This points to the first result byte
                        
  00F0                  IWIDTH: 	EQU  	0F0H
  000F                  FWIDTH: 	EQU  	0FH
                        
  0000   1000           			NOP
  0002                  EXTRA:		BSS		6
                        
                        ;
                        ; This storage is used to store the stack variables etc that small-C calls
                        ; to load and store the packed floating point numbers.
                        ; Actual manipulation and arithmatic is done using R5,R6, and R7 agains R5', R6' and R7'
                        ;
  0008                  			EVEN
  0008   0000           FLAGS:		WORD	0
  000A                  FPA:		BSS		2		;R5
  000C                  			BSS		2		;R6
  000E                  			BSS		2		;R7
                        
  0010                  DSIGN:		BSS		2		;msb indicates sign of FA, 0 is negative, 1 is positive
  0012                  			EVEN
  0012   2DA0 004A      DIVZERO: 	CALL	@GRIPE
  0016   6361 6E27      			TEXT	"can't"
  001A   74             
  001B   00             			BYTE	0
  001C                  			EVEN
  001C   2DA0 004A      ILLFCT:		CALL	@GRIPE
  0020   496C 6C65      			TEXT	"Illegal function"
  0024   6761 6C20      
  0028   6675 6E63      
  002C   7469 6F6E      
  0030   00             			BYTE	0
  0031   00             			EVEN
  0032   2DA0 004A      OFLOW:		CALL	@GRIPE
  0036   4172 6974      			TEXT	"Arithmetic overflow"
  003A   686D 6574      
  003E   6963 206F      
  0042   7665 7266      
  0046   6C6F 77        
  0049   00             			BYTE	0
  004A                  			EVEN
                        GRIPE:		;CALL	@QERR			;top word on stack points to message
  004A   0460 F000      			B		@0f000H  		;SHELL this a temporary hack - how do we handle fatal error
  004E                  			EVEN
                        
                        ;
                        ;  To do
                        ;
                        
                        _fpswap::
  004E   0200 001C      		LI	R0,001CH
  0052   2E80           		WHEX R0
  0054   0204 0000      		LI	R4,0
  0058   2DC0           		RET
                        
                        ;
                        ; LOAD FPN AT ADDRESS IN R4 INTO ACCUMULATOR
                        ;
  005A   0200 000A      _fload::	LI		R0,FPA			;Begin at register R5
  005E   0208 0006      			LI		R8,6
                        ;			WHEX	*R4
  0062   DC34           FLD1:		MOVB 	*R4+,*R0+		;Move byte at a time
  0064   0608           			DEC		R8
  0066   16FD           			JNE		FLD1
  0068   2DC0           			RET
                        
                        ;
                        ;	STORE FROM FPA TO THE ADDRESS IN R4
                        ;
  006A   0200 000A      _fstore::	LI		R0,FPA			;Begin at Register 5
  006E   0208 0006      			LI		R8,6
  0072   DD30           FST1:		MOVB	*R0+,*R4+
  0074   0608           			DEC		R8
  0076   16FD           			JNE		FST1
  0078   2DC0           			RET
                        
                        ;
                        ;	load FPA from (R4) and push FA (fall through to _fpush
                        ;
                        _fldpsh::
  007A   0200 000A      			LI		R0,FPA
  007E   CC34           			MOV		*R4+,*R0+	;R5
  0080   CC34           			MOV		*R4+,*R0+	;R6
  0082   C414           			MOV		*R4,*R0		;R7
                        ;	push the floating point accumulator
                        ;	(preserving return address)
                        ;
  0084   CA9A FFFA      _fpush::	MOV		*SP,@-6(SP)		;New location for return address at top of stack
  0088   CAA0 000E      			MOV		@FPA+4,@-4(SP)  ;Push R7
  008C   FFFC           
  008E   CAA0 000C      			MOV 	@FPA+2,@-2(SP)	;Push R6
  0092   FFFE           
  0094   C6A0 000A      			MOV 	@FPA,*SP		;Push R5
  0098   022A FFFA      			AI		SP,-6			;SP NOW POINTS TO RETURN ADDRESS
  009C   2DC0           			RET
                        ;
                        ;	push floating point accumulator
                        ;	(preserve return address and next stacked word)
                        ;
                        ;
                        _fpush2x::
  009E   2E44           			POP		R4			;GRAB RETURN ADDRESS
  00A0   2E42           			POP		R2			;SAVE THE NEXT WORD
  00A2   0201 000A      			LI		R1,FPA
  00A6   064A           			DECT	SP
  00A8   C6B1           			MOV 	*R1+,*SP	;R5
  00AA   064A           			DECT	SP
  00AC   C6B1           			MOV 	*R1+,*SP	;R6
  00AE   064A           			DECT	SP
  00B0   C691           			MOV 	*R1,*SP		;R7
  00B2   2E02           			PUSH	R2			;PUSH BACK THE ORIGINAL WORD
  00B4   2E04           			PUSH	R4			;PUSH RETURN ADDRESS AND THEN RETURN
  00B6   2DC0           			RET
                        
                        ;	DO IT THIS WAY TO AVOID PUSHS AND POPS
                        ;	push floating point accumulator
                        ;	(preserve return address and next stacked word)
                        
  00B8   0200 0003      _fpush2:: 	LI	R0,0003H
  00BC   2E80           			WHEX	R0
  00BE   CA9A FFFA      			MOV		*SP,@-6(SP)		;New location for return address at top of stack
  00C2   CAA0 000E      			MOV		@FPA+4,@-4(SP)  ;Push R7
  00C6   FFFC           
  00C8   CAA0 000C      			MOV 	@FPA+2,@-2(SP)	;Push R6
  00CC   FFFE           
  00CE   C6A0 000A      			MOV 	@FPA,*SP		;Push R5
  00D2   022A FFFA      			AI		SP,-6			;SP NOW POINTS TO RETURN ADDRESS
  00D6   2DC0           			RET
                        
                        ;
                        ;FLOATING POINT ADDITION.
                        ;
                        ; Add R5, R6 and R7 to floating point accumulator
                        ;  STACK ORGANISED AS:
                        ;
                        ;  RETURN ADDRESS
                        ;  R7
                        ;  R6
                        ;  R5
                        ;
                        ; In aligning the comments of Math48 AC' will be the FPA and
                        ; AC will be R5, R6 and R7
                        ; AC' is equivalent to R5',R6' and R7'
                        ;
                        ; Left Sign | 	Right Sign | Left Mant > Right Man| COmpute As |  Result Is
                        ;
                        ;	    -			+			Yes					LM - RM			-
                        ;		+			-			Yes					LM - RM			+
                        ;		-			+			No					RM - LM			+
                        ;		+			-			No					RM - LM			-
                        ;
                        ;
                        ; ;    Addition
                        ;     --------
                        ;
                        ;     NAME:      FPADD
                        ;     FUNCTION:  AC=AC+AC'. The number in AC' is added to the
                        ;                number in AC and the result is placed in AC.
                        ;     OFFSET:    00H
                        ;     OUTPUT:    CF=0: OK.
                        ;                CF=1: Overflow.
                        ;     STACK:     10 bytes
                        ;
                        ;
                        
  00D8   0200 0004      _fpadd::  	LI		R0,0004H
  00DC   2E80           			WHEX 	R0
                        
  00DE   02AD           			STWP	WP				;Need to offset into wp
  00E0   2E44           			POP		R4				;save return address
  00E2   2E43           			POP		R7'				;Get AC'
  00E4   2E42           			POP		R6'
  00E6   2E41           			POP		R5'
  00E8   2E04           			PUSH	R4				;replace return address
                        ;
                        ; Now get the FPA into AC
                        ;
  00EA   0200 004A      			LI		R0,004AH
  00EE   2E80           			WHEX 	R0
                        
  00F0   2DA0 05D2      			CALL	@GETAC			;Copy FPA into AC
  00F4   2E81           			WHEX	R5'
  00F6   2E82           			WHEX	R6'
  00F8   2E83           			WHEX	R7'
  00FA   2E85           			WHEX	R5
  00FC   2E86           			WHEX	R6
  00FE   2E87           			WHEX	R7
                        
                        
  0100   0C09 002D      			TMB		@2*R5'(WP),0	;Is AC' Negative?
  0104   0002           
  0106   1602             			JNE		ADD1			; No
  0108   0460 022E      			B		@SUB1			;Yes => SUB1
                        
  010C   0200 0051      ADD1:   	LI	R0,0051H
  0110   2E80           			WHEX R0
                        
  0112   D02D 0007      			MOVB	@2*R7'+1(WP),R0	;Is AC' zero?
  0116   1601           			JNE		ADD1A
  0118   2DC0                  		RET  		      		;Yes => Return
                        ;
                        ; At this point we have AC and AC' populated and we know
                        ; that AC' is both non zero and positive
                        ;
  011A   0200 004B      ADD1A:      LI	R0,004BH
  011E   2E80           			WHEX R0
                        
  0120   D02D 000F      			MOVB	@2*R7+1(WP),R0	;Is AC zero?
  0124   1604                   	JNE		ADD2    		;No => ADD2
  0126   0C0A 002D              	TCMB	@2*R5'(WP),0	;Make AC' Positive
  012A   0002           
  012C   1064                    	JMP   	ADD10
                        
  012E   0200 CCCC      ADD2:   	LI	R0,0CCCCH
  0132   2E80           			WHEX R0
  0134   C105           			MOV		R5,R4			;Save AC sign for next operation
  0136   0208 8000      			LI		R8,SIGN*256
  013A   F148                    	SOCB	R8,R5			;Set AC MSB as Negative
  013C   F048                    	SOCB	R8,R5'			;Set AC' MSB as Negative
  013E   04C8                    	CLR		R8				;Need to clear LSB for for ADD3
  0140   D02D 000F               	MOVB	@2*R7+1(WP),R0	;EXP
  0144   D22D 0007               	MOVB	@2*R7'+1(WP),R8	;EXP'
  0148   7200                     	SB		R0,R8	        ;R8 => EXP'- EXP (MSB)
  014A   1317                   	JEQ		ADD4     		;EXP = EXP' => ADD4
  014C   1805                   	JOC		ADD3    		;EXP < EXP' => ADD3
                        ;
                        ;	Negative difference so we have to make positive
                        ;   R8 behaves as an AF AF' pair MSB is AF and LSB is AF'
                        ;
  014E   0508                   	NEG		R8         		;Make R8 MSB positive
  0150   0248 FF00              	ANDI	R8,0FF00H		;Mask of Low Byte
  0154   2DA0 05B6              	CALL	@EXX			;We have to adjust AC'
                        ;
                        ;	R8 HOLDS THE DIFFERENCE OR ADJUSTMENT NEEDED
                        ;   IF EXP < EXP' ADJUST EXP UP
                        ;   IF EXP > EXP' ADJUST EXP' UP
                        ;
                        
  0158   0200 0066      ADD3:		LI		R0,0066H
  015C   2E80           			WHEX 	R0
                        
  015E   2DA0 0502      			CALL 	@SRIGHT     	;Shift AC to the right by 1 position
  0162   0200 0100      			LI		R0,256
  0166   BB40 000F      			AB		R0,@2*R7+1(WP)	;Increment exponent and check if  EXP=EXP'?
  016A   0228 FF00              	AI  	R8,-256    		;DEC difference
  016E   16F4                     	JNE	 	ADD3    		;No => ADD3
  0170   06C8                     	SWPB	R8				;Equivalent to EX AF, AF'
  0172   D008                     	MOVB	R8,R0			;Was it AC'
  0174   1302                     	JEQ		ADD4			;No => ADD4
  0176   2DA0 05B6                	CALL	@EXX			;Yes=>Exchange for for AC
                        
                        ; First check if the incoming AC was negative so we can reapply sign
  017A   0200 0041      ADD4:   	LI		R0,0041H
  017E   2E80           			WHEX 	R0
                        
  0180   0C09 002D      			TMB		@2*R4(WP),0		;Was R5 (AC) MSB negative?
  0184   0008           
  0186   130F            			JEQ		ADD5	   		;If it is negative => ADD5
                        
  0188   2DA0 03AC              	CALL 	@ADDAC      	;MANT=MANT+MANT'
  018C   1730                   	JNC		ADD9    		;No carry/overflow then => ADD9
                        ;
                        ; There has been an overflow so we need to rotate the mantissa to the right 1 place
                        ;
  018E   0200 0042      			LI		R0,0042H
  0192   2E80           			WHEX 	R0
  0194   0700                   	SETO	R0				;Set for carry
  0196   2DA0 0504              	CALL 	@RIGHT      	;Rotate to the right
  019A   0200 0100              	LI		R0,256
  019E   BB40 000F              	AB		R0,@2*R7+1(WP)	;Increment the exponent by 1
  01A2   1625            	        JNE		ADD9
  01A4   1028           	        JMP		ADD10
                        
  01A6   0200 0043      ADD5:   	LI		R0,0043H
  01AA   2E80           			WHEX 	R0
                        ;    			AC=AC' => JEQ.
                        ;               AC>AC' => JGT
                        ;               AC<AC' => JLT.
                        
  01AC   2DA0 0402      			CALL 	@CMPAC      	;Compare
  01B0   02CF           			STST	ST				;Save the status register
  01B2   0200 4000      			LI		R0,AGT			;Arithmetic Greater Than Bit Mask
  01B6   2BC0           			XOR		R0,ST			;Complement the carry bit
  01B8   008F           			LST		ST				;Load the stutus register
  01BA   1313                   	JEQ		ADDZ     		;AC=AC' => ADDZ
  01BC   1502                   	JGT		ADD6     		;AC>AC' => ADD6
  01BE   2DA0 05B6      			CALL	@EXX			;AC<AC' => Swap
                        
  01C2   2DA0 03D4      ADD6:   	CALL 	@SUBAC      	;MANT=MANT-MANT'
                        
  01C6   0C09 002D      ADD7:   	TMB		@2*R5(WP),0		;Test the sign bit - is it normalised
  01CA   000A           
  01CC   130C           			JEQ		ADD8			;Yes => ADD8
  01CE   2DA0 052C              	CALL 	@SLEFT      	;Shift left one bit
  01D2   D02D 000F              	MOVB	@2*R7+1(WP),R0
  01D6   1305                    	JEQ		ADDZ     		;No  => AC zero
  01D8   0220 FF00              	AI	  	R0,-1*256 		;Subtract 1 from the exponent
  01DC   DB40 000F              	MOVB	R0,@2*R7+1(WP)	;Update exponent
  01E0   10F2                   	JMP		ADD7
                        
  01E2   2DA0 04F6      ADDZ:   	CALL 	@ZERO
                        
  01E6   0200 0044      ADD8:   	LI		R0,0044H
  01EA   2E80           			WHEX 	R0
  01EC   008F           			LST		ST         		;Get sign from ADD5 Compare
  01EE   1503           ADD9:   	JGT		ADD10    		;Carry => negative
                        
  01F0   0C0A 002D      			TCMB	@2*R5(WP),0		;Clear sign bit
  01F4   000A           
                        ;
                        ;  Common routine need to check if it is correct
                        ;
  01F6   0200 0045      ADD10:  	LI	R0,0045H
  01FA   2E80           			WHEX R0
  01FC   2DA0 05E0      			CALL	@PUTAC			;Put AC into the FPA
  0200   2DC0                   	RET
                        
                        ;
                        ;
                        ;FLOATING POINT SUBTRACTION
                        ;;
                        ;	subtract the floating point accumulator (AC) from the value
                        ;	on the stack (AC') (under the return address), leave result
                        ;	in the floating point accumulator.
                        ;     Subtraktion
                        ;     ------------
                        ;
                        ;     NAME:      FPSUB
                        ;     FUNCTION:  AC=AC-AC'. The number in AC' is subtracted from
                        ;                the number in AC and the result is placed in AC.
                        ;     OFFSET:    03H
                        ;     OUTPUT:    CF=0: OK.
                        ;                CF=1: Overflow.
                        ;     STACK:     12 bytes.;
                        ;
                        ;
  0202   0200 000A      _fpsub::   	LI	R0,000AH
  0206   2E80           			WHEX R0
  0208   02AD           			STWP	WP				;Need to offset into wp for some operations
                        ;
                        ;	add the value on the stack (under the return address)
                        ;	to the floating point accumulator
                        ;
                        
  020A   2E44           			POP		R4					;save return address
  020C   2E43           			POP		R7'					;Get AC'
  020E   2E42           			POP		R6'
  0210   2E41           			POP		R5'
  0212   2E04           			PUSH	R4					;replace return address
                        
                        
  0214   0200 0066      			LI		R0,0066H
  0218   2E80           			WHEX	R0
  021A   2DA0 05D2      			CALL	@GETAC
  021E   2DA0 05B6      			CALL	@EXX				;Now we have AC - AC'
                        
                        ;			WHEX	R5'
                        ;			WHEX	R6'
                        ;			WHEX	R7'
                        
                        
  0222   0C09 002D      			TMB		@2*R5'(WP),0		;Is AC' negative?
  0226   0002           
  0228   1602           			JNE		SUB1				;Yes => ADD1
  022A   0460 010C      			B		@ADD1
                        
  022E   2DA0 038E      SUB1:   	CALL 	@FPNEG      		;AC=-AC
  0232   2DA0 010C              	CALL 	@ADD1       		;Add AC' to  AC
                        ;        	CALL 	@FPNEG
  0236   2DA0 05E0              	CALL	@PUTAC
  023A   2DC0                   	RET
                        
                        
                        ;FLOATING POINT DIVISION.
                        ; For a flowchart of the algorithm
                        ; see BYTE Magazine Volume 2, issue 11 (November, 1977)
                        ;
                        ;
                        ;     NAME:      FPDIV
                        ;     FUNCTION:  AC=AC/AC'. The number in AC is divided by the
                        ;                number in AC' and the result is placed in AC.
                        ;     OFFSET:    09H
                        ;     OUTPUT:    CF=0: OK.
                        ;                CF=1: Overflow or AC' equal to 0.
                        ;     STACK:     32 bytes.
                        ;
                        ;
                        ;	divide the value on the stack (under the return
                        ;	address) by the floating point accumulator, leave
                        ;	result in the floating point accumulator.
                        ;
                        ;   Result is (ACs/AC's)x2^(EXP-EXP')
                        ;
                        ;  DIVIDEND = 2^2+2^3+2^4 etc
                        ;	-------   ---------------
                        ;  DIVISOR  = 2^2+2^3+2^4 etc
                        ;
                        ;
                        
                        _fpdiv::
  023C   02AD           FPDIV: 		STWP	WP
  023E   2E44           			POP		R4					;save return address
  0240   2E43           			POP		R7'					;Get AC'
  0242   2E42           			POP		R6'
  0244   2E41           			POP		R5'
  0246   2E04           			PUSH	R4					;replace return address
                        
  0248   2DA0 05D2      			CALL	@GETAC
  024C   2DA0 05B6      			CALL	@EXX				;Now are now ready for AC/AC'
                        
  0250   D02D 0007      			MOVB	@2*R7'+1(WP),R0		;Is AC' zero
  0254   1602                   	JNE		DIVI_A
  0256   0460 033A              	B		@MULSA1		       	;Yes => Overflow
                        
  025A   D12D 000F      DIVI_A:		MOVB	@2*R7+1(WP),R4		; Is AC zero?
  025E   1602                   	JNE		DIVI_B
  0260   0460 033A              	B		@MULSA1						        ;Yes, => Return
                        
  0264   0208 1111      DIVI_B:		LI		R8,1111H
  0268   2E88           			WHEX	R8
  026A   7100           			SB		R0,R4      			;Adjust exponent by calling EXPSGN
                        
  026C   C24A                   	MOV		SP,R9				;R9 will be used as Workspace Pointer on the stack
  026E   0229 FFE0              	AI		R9,-32				;Allocate Stack Registers R0 to R7. R5, R6, R7 holds the result
                        										;Higher registers are not used as they will be overwritten during calls
  0272   0200 0005      			LI		R0,5				;Use is 5 bytes, each with 8 bits
  0276   CA40 0002      			MOV		R0,@2*R1(R9)		;R1 (STACK) hold number of bytes
  027A   0200 0008      			LI		R0,8				;Number of bits per byte
  027E   CA40 0004      			MOV		R0,@2*R2(R9)		;R2 (STACK) hold number of bits
  0282   04C0           			CLR		R0					;Result offset byte.  Points to first byte initially
  0284   CA40 0006      			MOV		R0,@2*R3(R9)		;R3 Offset Byte to point to result byte
  0288   CA40 000A      			MOV		R0,@2*R5(R9)		;Clear the result
  028C   CA40 000C      			MOV		R0,@2*R6(R9)		;Clear the result
  0290   CA40 000E      			MOV		R0,@2*R7(R9)		;Clear the result
                        ;
                        ;  CALL EXPSGN to
                        ;  1.Exclusive OR Signs to get Resultant Sign
                        ;  2.Subtract Divisor Exponenet from Dividend Exponent
                        ;  Place both these results onto the result space allocated on the stack
                        ;
  0294   2DA0 0340      			CALL 	@EXPSGN     		;calculate sign i.e. (EXP-EXP')
  0298   0208 1112      			LI		R8,1112H
  029C   2E88           			WHEX	R8
                        
  029E   04C4           DIVI1:		CLR		R4					;Clear Carry Flag
  02A0   2DA0 0402      			CALL	@CMPAC				;Is MANT>MANT'
  02A4   1103           			JLT		DIVI2				;No =>DIVI2
  02A6   2DA0 03D4      			CALL	@SUBAC				;Subtract AC'from AC (Divident - Divisor)
  02AA   0584           			INC		R4
                        
  02AC   C229 0006      DIVI2:		MOV		@2*R3(R9),R8		;Get current result byte offset
  02B0   A209           			A		R9,R8				;R4 points to the current byte on the stack
  02B2   D028 000A      			MOVB	@RES_BYTE(R8),R0	;get result or quotient
  02B6   0A10           			SLA		R0,1
  02B8   C104           			MOV		R4,R4
  02BA   1301           			JEQ		DIVI2A
  02BC   0580           			INC		R0					;Add carry
                        
  02BE   CA00 000A      DIVI2A:		MOV		R0,@RES_BYTE(R8)	;Copy temp buffer
  02C2   0629 0004      			DEC		@2*R2(R9)			;more bits in this byte?
  02C6   160C           			JNE		DIVI3
                        
  02C8   0200 0008      			LI		R0,8				;Number of bits per bytes
  02CC   CA40 0004      			MOV		R0,@2*R2(R9)		;R2 (STACK) hold number of bits
  02D0   C029 0006      			MOV		@2*R3(R9),R0		; Get current result offset
  02D4   0580           			INC		R0
  02D6   CA40 0006      			MOV		R0,@2*R3(R9)
  02DA   0280 0005      			CI		R0,5				;Are we finished?
  02DE   1307           			JEQ		DIVI4
                        
  02E0   2DA0 052C      DIVI3:		CALL	@SLEFT				;Shift AC to the Left (Dividend is result of subtraction)
  02E4   17DC           			JNC		DIVI1				;No carry => DIVI1
                        
  02E6   2DA0 03D4      			CALL	@SUBAC				;MANT=MANT-MANT'
  02EA   04C0           			CLR		R0					;Reset carry
  02EC   10DF           			JMP		DIVI2
                        
  02EE   2DA0 052C      DIVI4:		CALL	@SLEFT				;;Calculate the rounding bit
  02F2   1802           			JOC		DIVI5
  02F4   2DA0 0402      			CALL	@CMPAC
                        
                        
  02F8   0C09 002D      DIVI5:		TMB		@2*R5(WP),0			;Normalised?
  02FC   000A           
  02FE   1303           			JEQ		DIVI6				;Yes => DIVI6
                        
  0300   2DA0 052E      			CALL	@LEFT				;Rotate rounding bit
  0304   100E           			JMP		MUL5				;into result
                        
  0306   0587           DIVI6:		INC		R7					;Add 1 to the exponent
  0308   160C           			JNE		MUL5
  030A   0607           			DEC		R7
  030C   100B           			JMP		MUL5A
                        
                        ;FLOATING POINT MULTIPLIKATION
                        ;     Multiplication
                        ;     --------------
                        ;
                        ;     NAME:      FPMUL
                        ;     FUNCTION:  AC=AC*AC'. The number in AC is multiplied by
                        ;                the number in AC' and the result is placed in AC.
                        ;     OFFSET:    06H
                        ;     OUTPUT:    CF=0: OK.
                        ;                CF=1: Overflow.
                        ;     STACK:     16 bytes.
                        ;
                        
                        
                        FPMUL:
                        _fpmul::
  030E   0200 001B      		LI	R0,001BH
  0312   2E80           		WHEX R0
  0314   0204 0000      		LI	R4,0
  0318   2DA0 04F6      		CALL	@ZERO
  031C   2DA0 05E0      		CALL	@PUTAC
  0320   2DC0           		RET
  0322   04C0           MUL5:		CLR		R0
  0324   C169 000A      MUL5A:  	MOV		@2*R5(R9),R5			;Move result into AC
  0328   C1A9 000C      			MOV		@2*R6(R9),R6			;Move result into AC
  032C   C1E9 000E      			MOV		@2*R7(R9),R7			;Move result into AC
  0330   D029 000F      			MOVB	@2*R7+1(R9),R0
  0334   1602           			JNE		MULSA1
  0336   2DA0 04F6      			CALL	@ZERO
  033A   2DA0 05E0      MULSA1:		CALL	@PUTAC
  033E   2DC0           			RET
                        
                        
                        
                        ;
                        ;Adjust exponent and calculate sign.
                        ; Value of exponent is in R4
                        ; R9 points to the workspace on the stack
                        ;
                        ;
                        
  0340   1105           EXPSGN:		JLT		EXPS1				;If less than => EXPS1
  0342   0200 8000      			LI		R0,EXPN*256
  0346   B100           			AB		R0,R4				;Adjust exponent for radix 2
  0348   1906           			JNO		EXPS2				;No overflow => EXPS2
  034A   101B           			JMP		EXPS3				;Underflow
                        
                        
  034C   0200 8000      EXPS1:		LI		R0,EXPN*256
  0350   B100           			AB		R0,R4				;Adjust exponent for radix 2
  0352   1901           			JNO		EXPS2
  0354   1016           			JMP		EXPS3				;Overflow
                        
                        
  0356   0208 1115      EXPS2:		LI		R8,1115H
  035A   2E08           			PUSH	R8
  035C   2E88           			WHEX	R8
  035E   2E48           			POP R8
                        
  0360   DA44 000F      			MOVB	R4,@2*R7+1(R9)		;This is the resultant EXPN
                        
  0364   D02D 0002      			MOVB	@2*R5'(WP),R0		;Get AC' Sign
  0368   0C0B 002D      			TSMB	@2*R5'(WP),0		;Set both of them to 1
  036C   0002           
  036E   0C0B 002D      			TSMB	@2*R5(WP),0			;Calculate new sign
  0372   000A           
  0374   282D 000A      			XOR		@2*R5(WP),R0		;XOR to determine resultant sign
  0378   2C6D 000A      			XOP		@2*R5(WP),1
  037C   DA40 000A      			MOVB	R0,@2*R5(R9)		;Sign of resultant or quotient
  0380   2DC0           			RET
                        
                        EXPS3:		;Adjust stack?
  0382   0208 1113      			LI		R8,1113H
  0386   2E08           			PUSH	R8
  0388   2E88           			WHEX	R8
  038A   2E48           			POP		R8
  038C   2DC0           			RET
                        
                        ;
                        ; Complement the sign bit
                        ;
                        
                        
  038E   D02D 000F      FPNEG:  	MOVB	@2*R7+1(WP),R0   	;Is AC zero?
  0392   1303                   	JEQ		FP_RET      	 	;Yes => Return
  0394   0200 8000              	LI		R0,SIGN*256
  0398   2940                  	 	XOR  	R0,R5				;Complement sign
  039A   2DC0           FP_RET:     RET
                        
                        
                        MINUSFPA:
                        _minusfa::
  039C   C120 000A      			MOV		@FPA,R4
  03A0   0200 8000      			LI		R0,SIGN*256
  03A4   2900           			XOR		R0,R4
  03A6   C804 000A      			MOV		R4,@FPA
  03AA   2DC0           			RET
                        
                        ;
                        ;Add AC 'to AC..Result in AC and set carry flag if applicable
                        ;
                        
  03AC   04C0           ADDAC:  	CLR		R0				;This is the carry register
  03AE   0580           			INC		R0
  03B0   02CF           			STST	ST				;Save status with no carry or overflow set
  03B2   B1C3           			AB		R7',R7
  03B4   1705           			JNC		AAC1
  03B6   A180           			A		R0,R6
  03B8   1703           			JNC		AAC1
  03BA   A140           			A		R0,R5
  03BC   1701           			JNC		AAC1
  03BE   02CF           			STST	ST				;Carry to AC  has occured i.e. R5
                        ; Now add the registers together
                        
  03C0   A182           AAC1:		A		R6',R6
  03C2   1703           			JNC		AAC2
  03C4   A140           			A		R0,R5
  03C6   1701           			JNC		AAC2
  03C8   02CF           			STST	ST				;Carry to AC has occured i.e. R5
                        
  03CA   A141           AAC2:		A		R5',R5
  03CC   1701           			JNC		AAC3
  03CE   02CF           			STST	ST				;Carry to AC has occured i.e. R5
  03D0   008F           AAC3:		LST		ST
  03D2   2DC0                       RET
                        
                        ;
                        ;Subtract AC'from AC. - Set ST1 = 0 if LT, ie AC<AC'
                        ;
  03D4   0200 0005      SUBAC:  	LI	R0,0005H
  03D8   2E80           			WHEX R0
  03DA   04C0           	  		CLR		R0				;Clear carry and prime carry bit
  03DC   0580           			INC		R0
  03DE   02CF           			STST	ST				;Save status with no carry or overflow set
  03E0   71C3           			SB		R7',R7
  03E2   1705           			JNC		SAC1
  03E4   A080           			A		R0,R6'
  03E6   1703           			JNC		SAC1
  03E8   6040           			S		R0,R5'
  03EA   1701           			JNC		SAC1
  03EC   02CF           			STST	ST				;Carry to AC  has occured from. R5
                        ;
                        ; Now subtract the registers AC - AC'
                        ;
  03EE   6182           SAC1:   	S		R6',R6
  03F0   1703           			JNC		SAC2
  03F2   A040           			A		R0,R5'
  03F4   1701           			JNC		SAC2
  03F6   02CF           			STST	ST   			;Carry to AC  has occured from R5
                        
  03F8   6141           SAC2:		S		R5',R5			;
  03FA   1701           			JNC		SAC3
  03FC   02CF           			STST	ST
  03FE   008F           SAC3:		LST		ST
  0400   2DC0            			RET
                        ;
                        ;Compare AC to AC '
                        ;
                        ;
                        ;     NAME:      CMP
                        ;     FUNCTION:  Compare AC to AC' using subtraction, i.e. AC - AC'.
                        ;     OFFSET:    12H
                        ;    			ST2=1: 			AC=AC' => JEQ.
                        ;               ST0=1 ST2=0: 	AC>AC' => JGT.
                        ;               ST0=3 			AC<AC' => JLT.
                        ;     STACK:     2 bytes
                        ;
                        ;
  0402   0200 0006      CMPAC:  	LI		R0,0006H
  0406   2E80           			WHEX 	R0
  0408   8045           			C		R5,R5'
  040A   1301           			JEQ		CMP1
  040C   1004           			JMP		CMP_RET
                        
  040E   8086           CMP1:		C		R6,R6'
  0410   1301           			JEQ		CMP2
  0412   1001           			JMP		CMP_RET
                        
  0414   90C7           CMP2:		CB		R7,R7'
                        
  0416   2DC0           CMP_RET:  	RET
                        ;
                        ;	Double precision comparisons
                        ;
                        ;	each compares top of stack
                        ;	(under two return addresses) to FA
                        ;
                        ;TOS >= FA?
                        ;
  0418   2DA0 0452      _fpge::		CALL	@DCOMPAR
  041C   1305           			JEQ		YES			;z => equal
  041E   1303           			JEQ		DG			;remaining tests are shared
                        ;
                        ;TOS > FA?
                        ;
  0420   2DA0 0452      _fpgt::		CALL	@DCOMPAR
  0424   130C           			JEQ		NO			;z => equal
  0426   100B           DG:			JMP		NO			;p => not greater than
  0428   0204 0001      YES:		LI		R4,1		;load "true"
  042C   2DC0           			RET
                        
                        ;
                        ;TOS <= FA?
                        ;
  042E   2DA0 0452      _fple::		CALL	@DCOMPAR
  0432   13FA           			JEQ		YES
  0434   1003           			JMP		DL
                        ;
                        ;TOS < FA?
                        ;
  0436   2DA0 0452      _fplt::		CALL	@DCOMPAR
  043A   1301           			JEQ		NO
  043C   11F5           DL:			JLT		YES			;p => less than
  043E   04C4           NO:			CLR		R4			;load "false"
  0440   2DC0           			RET
                        ;
                        ;TOS == FA?
                        ;
  0442   2DA0 0452      _fpeq::		CALL	@DCOMPAR
  0446   13F0           			JEQ		YES
  0448   10FA           			JMP		NO
                        
                        ;
                        ;TOS != FA?
                        ;
  044A   2DA0 0452      _fpne::		CALL	@DCOMPAR
  044E   13EC           			JEQ		YES
  0450   10F6           			JMP		NO
                        
                        
                        ;
                        ;FLOATING POINT COMPARE.  TEST IF EQUAL.
                        ;
                        ;common routine to perform double precision comparisons
                        
                        
                        DCOMPAR:
  0452   0200 0006      			LI	R0,0006H
  0456   2E80           			WHEX R0
  0458   2E40           			POP		R0	;save 1st return addr
  045A   2E41           			POP		R1	;save 2nd return addr
  045C   2E47           			POP		R7  ;get number to compare
  045E   2E46           			POP		R6
  0460   2E45           			POP		R5
  0462   2E01           			PUSH	R1	;replace 2nd addr
  0464   2E00           			PUSH	R0	;replace 1st addr, fall into...
                        ;CMP:
  0466   2DC0            			RET
                        ;		EXX             ;Er fortegn ens?
                        ;        LD   A,B
                        ;        EXX
                        ;        XOR  B
                        ;        JP   P,CMP1     ;Ja => CMP1
                        ;        LD   A,B        ;Fortegn fra AC til
                        ;        RLA             ;carry
                        ;        RET
                        
                        ;CMP1: ;  BIT  7,B        ;Negative tal?
                         ;       JR   Z,CMP2     ;Nej => CMP2
                        
                        ;        CALL CMP2       ;Sammenlign abs.vaerdi
                         ;       RET  Z          ;Ens => Returner
                        ;        CCF             ;Complementer resultat
                        ;        RET
                        
                        ;CMP2:;   LD   A,L        ;Er exponenter ens?
                        ;        EXX
                        ;        CP   L
                        ;        EXX
                        ;        RET  NZ         ;Nej => Returner
                        ;        OR   A          ;Er exponenter nul?
                        ;        RET  Z          ;Ja => Returner
                        ;        JP   CMPAC      ;Sammenlign AC med AC'
                        
                        
                        ;
                        ;CONVERT A FLOATING POINT A 16 BIT INTEGER USES AC
                        ;
                        ;     Integer
                        ;     -------;
                        ;
                        ;     NAME:      INT
                        ;     FUNCTION:  AC>=0: AC is set equal to the nearest integer that is
                        ;                       less than or equal to the number in AC.
                        ;                AC<0:  AC is set equal to the nearest integer that is
                        ;                       larger than or equal to the number in AC.
                        ;     OFFSET:    30H
                        ;     STACK:     8 bytes.
                        ;     EXAMPLE:   INT(3.7)=3
                        ;                INT(-3.7)=-3
                        
  0468   0200 0007      INT:    	LI		R0,0007H
  046C   2E80           			WHEX 	R0
                        
  046E   02AD           			STWP	WP
  0470   0200 8001      			LI		R0,256*EXPN+1
  0474   D12D 000F      			MOVB	@2*R7+1(WP),R4      ;Is exponentially smaller
  0478   7100                   	SB  	R0,R4 				;than zero? DA-SA => DA
  047A   1702                   	JNC		INT1A
  047C   0460 04F6              	B		@ZERO     			;Yes => Result zero
                        
  0480   0584           INT1A:      INC  	R4					;Add 1 to include the sign bit
  0482   2DA0 05B6      			CALL	@EXX				;Exchange into AC'
  0486   2DA0 04F6      			CALL	@ZERO				;Zero AC which will be the mask
                        
  048A   0700           INT1:   	SETO	R0					;Used for carry. Carry flag sets all the bits that have
  048C   2DA0 0504              	CALL 	@RIGHT      		;than or equal to zero
  0490   0604                   	DEC  	R4
  0492   16FB                   	JNE		INT1
                        
  0494   51C3                   	SZCB	R7',R7				;We now have the mask in AC' so AND all bits in AC
  0496   4182                   	SZC		R6',R6				;that has an exponent
  0498   4141                   	SZC		R5',R5				;less than using AND
  049A   2DA0 05B6              	CALL	@EXX				;Now have AC
  049E   0460 01F6      INT2:   	B		@ADD10      		;Put it into FPA
                        
                        
                        ;
                        ;	negate FA, and push address of MINUSFA
                        ;	called to evaluate functions f(x) when the argument is
                        ;	negative and f() satisfies f(-x)=-f(x)
                        ;
  04A2   0200 0008      ODD:		LI	R0,0008H
  04A6   2E80           			WHEX R0
  04A8   2DA0 039C      			CALL	@MINUSFPA
  04AC   0200 039C      			LI		R0,MINUSFPA
  04B0   C11A           			MOV		*SP,R4
  04B2   C680           			MOV		R0,*SP
  04B4   0454           			B		*R4
                        
                        
                        
                        ; CONVERT THE 16-BIT INTEGER IN R4 WITH 2'S COMPLEMENT SIGN
                        ; TO FLOATING POINT NUMBER AND PLACE IN FPA.
                        ; AC IS REPRESENTED BY R5, R6 AND R7
                        ;
                        ;     Convert 16-bit integer to a floating point number
                        ;     -------------------------------------------------
                        ;
                        ;
                        ;     NAME:      FLOAT
                        ;     FUNCTION:  AC=FLOAT(R4). Convert the 16-bit 2's complement
                        ;                integer in R4 to floating point number format
                        ;                and save the result in AC and copy AC to FPA
                        ;     OFFSET:    3FH
                        ;     STACK:     2 bytes.
                        ;     EXAMPLE:   FLOAT(0001H)=1
                        ;                FLOAT (FFFFH)=-1
                        
                        float::
  04B6   0200 000B      _float::	LI	R0,000BH
  04BA   2E80           			WHEX R0
                        
  04BC   02AD           			STWP	WP			;We may need this
  04BE   C004           			MOV		R4,R0        ;Is R4=0?
  04C0   131A                   	JEQ		ZERO         ;YES => ZERO
                        
  04C2   0A10           			SLA		R0,1		;Is bit 8 negative?
  04C4   02CF           			STST 	ST			;Save sign in ST via status register
  04C6   1701           			JNC		FLT1		;No => FLT1
  04C8   0504           			NEG		R4			;Take 2's complemnet ST2 is unchanged
                        
  04CA   C144           FLT1:  	 	MOV		R4,R5		;Set mantissa
  04CC   04C6                   	CLR		R6
  04CE   04C7                   	CLR		R7
  04D0   0204 0090              	LI		R4,EXPN+16	;Set inital value of exponent so we can normalise
                        
  04D4   C005           FLT2:   	MOV		R5,R0
  04D6   0A10           			SLA		R0,1        ;Now inovke the Normaliser
  04D8   1304                   	JEQ		FLT3		;If MSB is set then we have finished?
  04DA   2DA0 052C              	CALL 	@SLEFT		;No, so move R5,R6 and R7 one position to the left
  04DE   0604                   	DEC  	R4			;Adjuat the exponent
  04E0   10F9                   	JMP		FLT2
                        
  04E2   DB6D 0009      FLT3:   	MOVB	@2*R4+1(WP),@2*R7+1(WP)  ;Update the exponent
  04E6   000F           
  04E8   008F           			LST		ST     		;Was the original integer value negative?
  04EA   1802                   	JOC		FLT4   		;Yes => Return
  04EC   0245 7FFF              	ANDI	R5,7FFFH	;Clear Most Significant sign Bit
  04F0   2DA0 05E0      FLT4:      	CALL	@PUTAC		;Save the number in the FPA
  04F4   2DC0                 		RET
                        
                        ;
                        ;Reset AC. (R5, R6 and R7)
                        ;
  04F6   04C5           ZERO:   	CLR		R5  		;Reset carry, exponent of mantissa      ;
  04F8   04C6                   	CLR		R6
  04FA   04C7                   	CLR		R7
  04FC   2DA0 05E0              	CALL	@PUTAC		;Save the number in the FPA
  0500   2DC0           	        RET
                        
                        ;
                        ;Rotate AC to the right - Can only use R0. R0 will determine in carry in occurs
                        ;
  0502   04C0           SRIGHT:		CLR		R0			;Clear carry flag
  0504   CA80 FFFE      RIGHT: 		MOV		R0,@-2(SP)	; Save the carry flag by using stack space
                        
  0508   C007           RSR1:		MOV		R7,R0		;Preserve R7 and shift copy in R0
  050A   0910             			SRL		R0,1		;Not concerned about carry for R7
  050C   D1C0           			MOVB	R0,R7		;Restore R7 and the exponent and Now check for R6 carry into R7
  050E   0916           			SRL		R6,1		;If carry we need to add to R7
  0510   1702           			JNC		RSR5
  0512   0267 8000      			ORI		R7,SIGN*256	;Set MSB
                        
  0516   0915           RSR5:		SRL		R5,1
  0518   1702           			JNC		RSR6
  051A   0266 8000      			ORI		R6,SIGN*256	;Set MSB
                        
  051E   C02A FFFE      RSR6:		MOV		@-2(SP),R0	;Get it back from the stack space to check the carry in flag
  0522   0A10           			SLA		R0,1
  0524   1702           			JNC		RSR7
  0526   0265 8000      			ORI		R5,SIGN*256	;Set MSB
                        
  052A   2DC0           RSR7:		RET
                        
                        
                        
                        ;
                        ;Rotate AC to the left.
                        ;
                        
  052C   04C0           SLEFT:  	CLR		R0
  052E   0A15           LEFT:   	SLA		R5,1			;R5 HOLDS THE MSB OF THE FP
  0530   0A16           			SLA		R6,1			;SHIFT R5,R6 AND R7 TO THE LEFT ONE BIT
  0532   1701           			JNC		LSR7
  0534   0585           			INC		R5				;Add the carry to R5
  0536   D02D 000F      LSR7:		MOVB	@2*R7+1(WP),R0	;Need to preserve exponent
  053A   0A17           			SLA		R7,1
  053C   1701           			JNC		LSR8
  053E   0586           			INC		R6
  0540   DB40 000F      LSR8:		MOVB	R0,@2*R7+1(WP)	;Copy back the exponent
  0544   2DC0           			RET
                        
                        ;
                        ;
                        ;FLOATING POINT TO 16-BIT INTEGER (IN FPA ) WITH
                        ;2'S COMPLEMENT SIGN.
                        ;
                        ;THE BITS THAT WE NEED TO GRAB ARE IN THE MSB OF THE
                        ;FLOATING POINT REPRESENTATION, I.E.  REGISTERS R5 AND R6
                        ;
                        ;
                        ;
                        ;     Convert floating point number to a 16-bit integer
                        ;     -------------------------------------------------;
                        ;
                        ;     NAME:      FIX.
                        ;     FUNCTION:  HL=FIX(AC). convert the integer part of the floating
                        ;                number in AC to a 16-bit 2's complement integer, and
                        ;                save the result in the R4 register.
                        ;     OFFSET:    3CH
                        ;     OUTPUT:    CF=0: OK.
                        ;                CF=1: ABS(INT(AC)) > 32767
                        ;     STACK:     2 bytes.
                        ;     EXAMPLE:   FIX(1.5)=    1=  0001H
                        ;                FIX(-1.5)=  -1=  FFFFH
                        ;                FIX(0.5)=    0=  0000H
                        ;
                        _ifix::
  0546   0207 2222      ifix::		LI		R7,2222H
  054A   2E87           			WHEX	R7
  054C   02AD           			STWP	WP
  054E   2DA0 05D2         			CALL	@GETAC			;Get FPA into R5, R6 and R7
  0552   0C09 022D         			TMB		@2*R7(WP),8		;Exponent < 0?  MSB is bit 8
  0556   000E           
  0558   161D            			JNE		FIX4			;Yes => FIX4 as greater than zero
  055A   0C0B 002D         			TSMB	@2*R5(WP),0		;Test an set sign bit for shift operations not sign
  055E   000A           
  0560   02CF             			STST	ST				;Remember state of sign test
                        
  0562   C107                   	MOV		R7,R4			;Work on a copy of the exponent now
  0564   06C4                   	SWPB	R4
                        
  0566   0200 008F      FIX1:		LI		R0,EXPN+15		;Test exponent to see if it is lower than (0x8F)
  056A   06C0           			SWPB	R0				;Move to MSB
  056C   7004                 		SB		R4,R0			;too large to be an integer
  056E   1401                   	JHE		FIX1A
  0570   1011                   	JMP		FIX4			;EXP>15 => overflow
                        
  0572   1307           FIX1A:      JEQ		FIX2			;EXP=15 => FIX2
  0574   2DA0 0502              	CALL 	@SRIGHT     	;EXP<15 => rotate to
  0578   0224 0100              	AI		R4,256		  	;right and add 1 more to
  057C   DB44 000F              	MOVB	R4,@2*R7+1(WP)	;Update exponent
  0580   10F2                   	JMP   	FIX1	       	; Keep going
                        
  0582   2DA0 0502      FIX2: 		CALL 	@SRIGHT     	;Rotate to the right
  0586   008F                   	LST		ST				;Load status register from sign test
  0588   1603                   	JNE   	FIX3     		;Negative sign?  No => INT2
                        ; 			WHEX	R5
  058A   0505                   	NEG		R5       		;Convert to 2's complement
                        ;        	WHEX	R5
  058C   C105                   	MOV		R5,R4
  058E   2DC0                   	RET
                        
  0590   C105           FIX3:   	MOV		R5,R4        	;Get the final integer into R4
  0592   2DC0                   	RET
                        
  0594   04C4           FIX4:   	CLR		R4       		;Underflow, return -32768
  0596   2DC0                   	RET
                        
                        
                        ;
                        ;	return -(floor(-x))
                        ;
                        CEIL::
  0598   2DA0 04A2      _ceil::		CALL	@ODD
                        ;
                        ;   Return largest integer not greater than floor(x) returns the nearest
                        ;  integral value that is not greater than x. It is always true that
                        ;  floor(x) <= x
                        ;
                        ;  see https://stackoverflow.com/questions/24158625/is-it-possible-for-floor-to-return-an-inaccurate-result-due-to-floating-point#:~:text=The%20floor()%20function%20returns,that%20is%20an%20exact%20integer.&text=In%20other%20words%2C%20the%20true,arithmetic%20is%20less%20than%20i%20.
                        
                        ;floor(x) <= x
                        FLOOR::
  059C   0460 0546      _floor::	B		@_ifix			;temporary floor
                        
  05A0   D060 000A      			MOVB	@FPA,R1			;Get sign bit
  05A4   D120 000F      			MOVB	@FPA+5,R4		;fetch exponent
  05A8   0284 D900      			CI		R4,	0D9H*256	;(was A8H) larget negative exponent
  05AC   1801           			JOC		FLR1
  05AE   2DC0           			RET						;nc => binary point is right of lsb
                        
  05B0   2DA0 0468      FLR1:		CALL	@INT
  05B4   2DC0           			RET
                        ;
                        ;Set carry if the grade in A is a digit.
                        
                        ;GDTST:  	LD   A,(IX+0)
                        ;DIGTST: 	SUB  '0'
                        ;        	CCF
                         ;       	RET  NC
                        ;        	CP   10
                        ;        	RET
                        ;
                        ;DUPLICATE EQUIVALENT TO Z80 EXX
                        ;
  05B6   C005           EXX:		MOV		R5,R0
  05B8   C141           			MOV		R5',R5
  05BA   C040           			MOV		R0,R5'
                        
  05BC   C006           			MOV		R6,R0
  05BE   C182           			MOV		R6',R6
  05C0   C080           			MOV		R0,R6'
                        
  05C2   C007           			MOV		R7,R0
  05C4   C1C3           			MOV		R7',R7
  05C6   C0C0           			MOV		R0,R7'
  05C8   2DC0           			RET
                        ;
                        ;DUPLICATE EQUIVALENT TO Z80 EX FOR EXCHANGING STATUS REGISTERS
                        ;
  05CA   02C0           EXSR:		STST	R0			;SAVE CURRENT STATUS REGISTER
  05CC   008F           			LST		ST			;LOAD PREVIOUS STATUS REGISTER
  05CE   C3C0           			MOV		R0,ST		;SAVE CURRENT STATUS REGISTER IN SR
  05D0   2DC0           			RET
                        ;
                        ;GET FLOATING POINT NUMBER FROM FPA CONTENTS INTO R5, R6 AND R7
                        ;
  05D2   C160 000A      GETAC:		MOV		@FPA,R5
  05D6   C1A0 000C      			MOV		@FPA+2,R6
  05DA   C1E0 000E      			MOV		@FPA+4,R7
  05DE   2DC0           			RET
                        ;
                        ;PUT AC INTO FLOATING POINT ACCUMULATOR
                        ;
  05E0   C805 000A      PUTAC:		MOV		R5,@FPA
  05E4   C806 000C      			MOV		R6,@FPA+2
  05E8   C807 000E      			MOV		R7,@FPA+4
  05EC   2DC0           			RET
                        
                        ;
                        ;PUT AC' INTO FLOATING POINT ACCUMULATOR
                        ;
  05EE   C801 000A      PUTACP:		MOV		R5',@FPA
  05F2   C802 000C      			MOV		R6',@FPA+2
  05F6   C803 000E      			MOV		R7',@FPA+4
  05FA   2DC0           			RET
                        ;
                        ;Set AC to 1.
                        ;
                        
  05FC   0205 0000      AC1:    	LI		R5,00000H
  0600   0206 0000              	LI		R6,00000H
  0604   0207 0081              	LI		R7,00081H
  0608   2DC0                   	RET
                        ;
  060A                          	END

No error(s).
DIVI1     029E'   DL        043C'   ADDZ      01E2'   _fpdiv    023C'
YES       0428'   SAC1      03EE'   LEFT      052E'   SAC2      03F8'
FP_RET    039A'   SAC3      03FE'   ODD       04A2'   WP        000D 
RET       2DC0'   GRIPE     004A'   CBIT      1000    DIVI5     02F8'
_ceil     0598'   _fpeq     0442'   _fpgt     0420'   _minusfa  039C'
_fplt     0436'   WHEX      2E80'   CMP1      040E'   _fload    005A'
CMP2      0414'   INT       0468'   POP       2E40'   _float    04B6'
NO        043E'   EXX       05B6'   _fpush    0084'   FLD1      0062'
FPMUL     030E'   CMPAC     0402'   SLEFT     052C'   INT1      048A'
_fpush2x  009E'   R0        0000    FLT2      04D4'   INT2      049E'
FLT4      04F0'   R1        0001    FST1      0072'   R2        0002 
SIGN      0080    R3        0003    FPDIV     023C'   R4        0004 
ifix      0546'   AAC1      03C0'   DIVI_B    0264'   R5        0005 
RIGHT     0504'   AAC2      03CA'   AGT       4000    R6        0006 
EXTRA     0002'   AAC3      03D0'   ADD10     01F6'   R7        0007 
_fpswap   004E'   R8        0008    MULSA1    033A'   R9        0009 
_fpsub    0202'   PUSH      2E00'   _fpmul    030E'   DIVZERO   0012'
CMP_RET   0416'   _fpadd    00D8'   FPNEG     038E'   _fple     042E'
CALL      2D80'   _fpge     0418'   EXPN      0080    _fpne     044A'
EXPS3     0382'   DCOMPAR   0452'   EXSR      05CA'   DIVI6     0306'
float     04B6'   RSR1      0508'   SRIGHT    0502'   EXPSGN    0340'
MUL5      0322'   RSR5      0516'   LGT       8000    RSR6      051E'
ZERO      04F6'   RSR7      052A'   ILLFCT    001C'   AC1       05FC'
FPA       000A'   FIX1      0566'   FLT1      04CA'   FIX2      0582'
EXPS1     034C'   FIX3      0590'   MINUSFPA  039C'   FIX4      0594'
DIVI_A    025A'   ADD1      010C'   IWIDTH    00F0    FWIDTH    000F 
PUTAC     05E0'   ADD2      012E'   _fldpsh   007A'   ADD3      0158'
SUB1      022E'   ADD4      017A'   R11       000B    ADD5      01A6'
PUTACP    05EE'   ADD6      01C2'   _fpush2   00B8'   ADD7      01C6'
CEIL      0598'   RES_BYTE  000A    ADD1A     011A'   ADD8      01E6'
OFLOW     0032'   R5'       0001    DIVI2A    02BE'   R6'       0002 
DIVI3     02E0'   FLR1      05B0'   FLAGS     0008'   R7'       0003 
FLOOR     059C'   _floor    059C'   ADDAC     03AC'   LSR7      0536'
DG        0426'   ADD9      01EE'   FIX1A     0572'   INT1A     0480'
_ifix     0546'   LSR8      0540'   MUL5A     0324'   _fstore   006A'
DIVI4     02EE'   SP        000A    FLT3      04E2'   EXPS2     0356'
DSIGN     0010'   DIVI2     02AC'   GETAC     05D2'   ST        000F 
OVFLO     0800    SUBAC     03D4'
  CMP_RET   042A'   LSR7      054A'
_fpush2   00B8'   ADD9      01FC'   _fpgt     0434'   INT1A     0494'
SLEFT     0540'   LSR8      0554'   DIVI_A    0272'   _fstore   006A'
_fpsub    0210'   SP        000A    EXPS1     036C'   EXTRA     0002'
DSIGN     0010'   POP       2E40'   GETAC     05E6'   ST        000F 
OVFLO     0800    ODD       04B6'
