;       Math48 Floating Point Package
;       Version 1.1 Revision 1
;       by Anders Hejlsberg
;       2532 Bytes
;       TMS9900/99000 VERSION BY ALEXANDER CAMERON JUNE 2020
;		PARTS TAKEN FROM CFLOAT.C AS PART OF SMALLCPLUS
;
;
;
;Floating number format.
;   ============================================================
;
;     A floating number is made by the three 16-bit registers BC, DE and HL
;     (collectively called AC) or the corresponding alternative registers
;     BC', DE' og HL' (collectively called AC').;
;
;     The five 8-bit registers B,C,D,E and H (Collectively called BCDEH) represent
;     in the mentioned succession the number mantissa in binary representation.
;     The binary decimal point is placed immediately in front of the B register.
;     In this way, the bit 7 of B tell the number of halves (2^-1) in the number,
;     bit 6 the number of quarters (2^-2) etc.
;     The value of the mantissa may also be aprehended as the binary integer
;     BCDEH divided by 2^40.;
;
;     The L register contain the number exponent, that is the number 2 must be
;     raised to, to give the factor that the mantissa shall be multiplied by.
;     The absolute value of the L register is the exponent plus
;     128 (80H). If for example L has the value 83H the exponent will be 3.
;     If L has the value 7DH the exponent is -3.
;     If L is zero it tells that the whole number is zero. In this way the
;     exponent may take any integer value between -127 (01H) and 127 (FFH).
;
;     Of this it is seen that the number in AC shall be comprehended in the
;     following way.;
;
;         AC=(BCDEH/2^40)*2^(L-128)
;
;     Where BCDEH is a whole binary number.
;
;     As the exponent is the power that 2 shall be raised to, then it is given,
;     that the value of AC is doubled if one is added to the exponent, and
;     halved if one is subtracted from the exponent.
;     Likewise it is given that the number in BCDEH is doubled if it is shifted
;     one bit to the left and halved if it is shifted one bit to the right.
;     One may therefore, theoretically speaking, shift BCDEH to right or
;     left an arbitrary number of bits, as long as this number is added or
;     subtracted from the exponent.
;
;     The above stated is exploited in every calculation to normalize
;     the number in AC:
;     The mantissa (BCDEH) is repeatedly shifted one bit left untill the
;     most significant bit is set (bit 7 in B). Hereafter the number of shifts are
;     subtracted from the exponent.

;     This normalizing is done for two reasons: firstly is is
;     securing that the number has the maximum precision, as it
;     leaves the most significant bits in the mantissa.
;     Secondly it releases the most significant bit of the mantissa,
;     as this bit will always be set in a normalized number. The most
;     significant bit is in stead used as a sign indicator:
;     If it is set then the number is negative. If it is zero then the number
;     is positive. The absolute value of a number may thus be calculated
;     by simply resetting the bit 7 in the B register.
;
;     The construction of a floating number is compiled to:
;
;         Reg. Bit    Meaning;
;
;          B    7     Sign. 0=Positive. 1=Negative.
;          B   6-0    mantissa bit   38-32. Bit 39 always set.
;          C   7-0    mantissa bit   31-24.
;          D   7-0    mantissa bit   23-16.
;          E   7-0    hantisse bit   15-8.
;          H   7-0    hantisse bit   7-0.
;          L   7-0    L=0: the number is Zero.
;                     L>0: Exponent+128 (80H).;
;
;     If a floating point number is zero (ie. if the L register is zero)
;     then it does'nt matter what is in the mantissa as long as the sign
;     bit is zero.
;
;     Examples of floating point numbers (BCDEH and L in hexnotation):;
;
;      BCDEH       L   Value             Remarks;
;
;      0000000000  00  0                 L er nul.
;      0000000000  81  1                 2^-1*2^1.
;      0000000000  82  2                 2^-1*2^2.
;      8000000000  82  -2                Negative as bit 7 in B is set.
;      7000000000  84  15                (2^-1+2^-2+2^-3+2^-4)*2^4.
;      4800000000  87  100               (2^-1+2^-2+2^-5)*2^7.
;      4CCCCCCCCD  7D  0.1               Not final
;      0000000000  01  2.938735877E-39   Smallest possible number.
;      7FFFFFFFFF  FF  1.701411835E+38   Largest possible number.
;     ===================================================================
;
;
;     For the 9900 construction of a floating number is compiled to:
;
;         Reg. Bit    Meaning;
;
;       R5 MSB 7      Sign. 0=Positive. 1=Negative.
;       R5 MSB 6-0    mantissa bit   38-32. Bit 39 always set.
;       R5 LSB 7-0    mantissa bit   31-24.
;       R6 MSB 7-0    mantissa bit   23-16.
;       R6 LSB 7-0    mantisse bit   15-8.
;       R7 MSB 7-0    mantisse bit   7-0.
;       R7 LSB 7-0    L=0: the number is Zero.
;					  L>0: Exponent+128 (80H).;
;

R0			EQU 	0		;Free use
R1			EQU 	1		; Can be used but in some operations they are AC' prime registers
R2			EQU 	2		; Can be used but in some operations they are AC' prime registers
R3			EQU 	3		; Can be used but in some operations they are AC' prime registers
R4			EQU 	4		;Free use
R5			EQU 	5
R6			EQU 	6
R7			EQU 	7
R8			EQU 	8		;Free use
R5'			EQU		R1		;Prime register
R6'			EQU		R2		;Prime register
R7'			EQU		R3		;Prime register
R9			EQU		9
WP			EQU 	13		;WORKSAPCE REGISTER
ST			EQU		15		;STATUS REGISTER
SP			EQU 	10		;STACK POINTER
R11			EQU 	11

			DXOP 	CALL,6
			DXOP 	RET,7
			DXOP 	PUSH,8
			DXOP 	POP,9
			DXOP	WHEX,10

SIGN:   	EQU  	80H
EXPN:   	EQU  	80H
CBIT:		EQU		1000H
AGT:		EQU		4000H
LGT:		EQU		8000H
OVFLO:		EQU		0800H
RES_BYTE: 	EQU		2*R5			;This points to the first result byte

IWIDTH: 	EQU  	0F0H
FWIDTH: 	EQU  	0FH

			NOP
EXTRA:		BSS		6

;
; This storage is used to store the stack variables etc that small-C calls
; to load and store the packed floating point numbers.
; Actual manipulation and arithmatic is done using R5,R6, and R7 agains R5', R6' and R7'
;
			EVEN
FLAGS:		WORD	0
FPA:		BSS		2		;R5
			BSS		2		;R6
			BSS		2		;R7

DSIGN:		BSS		2		;msb indicates sign of FA, 0 is negative, 1 is positive
			EVEN
DIVZERO: 	CALL	@GRIPE
			TEXT	"can't"
			BYTE	0
			EVEN
ILLFCT:		CALL	@GRIPE
			TEXT	"Illegal function"
			BYTE	0
			EVEN
OFLOW:		CALL	@GRIPE
			TEXT	"Arithmetic overflow"
			BYTE	0
			EVEN
GRIPE:		;CALL	@QERR			;top word on stack points to message
			B		@0f000H  		;SHELL this a temporary hack - how do we handle fatal error
			EVEN

;
;  To do
;

_fpswap::
		LI	R0,001CH
		WHEX R0
		LI	R4,0
		RET

;
; LOAD FPN AT ADDRESS IN R4 INTO ACCUMULATOR
;
_fload::	LI		R0,FPA			;Begin at register R5
			LI		R8,6
;			WHEX	*R4
FLD1:		MOVB 	*R4+,*R0+		;Move byte at a time
			DEC		R8
			JNE		FLD1
			RET

;
;	STORE FROM FPA TO THE ADDRESS IN R4
;
_fstore::	LI		R0,FPA			;Begin at Register 5
			LI		R8,6
FST1:		MOVB	*R0+,*R4+
			DEC		R8
			JNE		FST1
			RET

;
;	load FPA from (R4) and push FA (fall through to _fpush
;
_fldpsh::
			LI		R0,FPA
			MOV		*R4+,*R0+	;R5
			MOV		*R4+,*R0+	;R6
			MOV		*R4,*R0		;R7
;	push the floating point accumulator
;	(preserving return address)
;
_fpush::	MOV		*SP,@-6(SP)		;New location for return address at top of stack
			MOV		@FPA+4,@-4(SP)  ;Push R7
			MOV 	@FPA+2,@-2(SP)	;Push R6
			MOV 	@FPA,*SP		;Push R5
			AI		SP,-6			;SP NOW POINTS TO RETURN ADDRESS
			RET
;
;	push floating point accumulator
;	(preserve return address and next stacked word)
;
;
_fpush2x::
			POP		R4			;GRAB RETURN ADDRESS
			POP		R2			;SAVE THE NEXT WORD
			LI		R1,FPA
			DECT	SP
			MOV 	*R1+,*SP	;R5
			DECT	SP
			MOV 	*R1+,*SP	;R6
			DECT	SP
			MOV 	*R1,*SP		;R7
			PUSH	R2			;PUSH BACK THE ORIGINAL WORD
			PUSH	R4			;PUSH RETURN ADDRESS AND THEN RETURN
			RET

;	DO IT THIS WAY TO AVOID PUSHS AND POPS
;	push floating point accumulator
;	(preserve return address and next stacked word)

_fpush2:: 	LI	R0,0003H
			WHEX	R0
			MOV		*SP,@-6(SP)		;New location for return address at top of stack
			MOV		@FPA+4,@-4(SP)  ;Push R7
			MOV 	@FPA+2,@-2(SP)	;Push R6
			MOV 	@FPA,*SP		;Push R5
			AI		SP,-6			;SP NOW POINTS TO RETURN ADDRESS
			RET

;
;FLOATING POINT ADDITION.
;
; Add R5, R6 and R7 to floating point accumulator
;  STACK ORGANISED AS:
;
;  RETURN ADDRESS
;  R7
;  R6
;  R5
;
; In aligning the comments of Math48 AC' will be the FPA and
; AC will be R5, R6 and R7
; AC' is equivalent to R5',R6' and R7'
;
; Left Sign | 	Right Sign | Left Mant > Right Man| COmpute As |  Result Is
;
;	    -			+			Yes					LM - RM			-
;		+			-			Yes					LM - RM			+
;		-			+			No					RM - LM			+
;		+			-			No					RM - LM			-
;
;
; ;    Addition
;     --------
;
;     NAME:      FPADD
;     FUNCTION:  AC=AC+AC'. The number in AC' is added to the
;                number in AC and the result is placed in AC.
;     OFFSET:    00H
;     OUTPUT:    CF=0: OK.
;                CF=1: Overflow.
;     STACK:     10 bytes
;
;

_fpadd::  	LI		R0,0004H
			WHEX 	R0

			STWP	WP				;Need to offset into wp
			POP		R4				;save return address
			POP		R7'				;Get AC'
			POP		R6'
			POP		R5'
			PUSH	R4				;replace return address
;
; Now get the FPA into AC
;
			LI		R0,004AH
			WHEX 	R0

			CALL	@GETAC			;Copy FPA into AC
			WHEX	R5'
			WHEX	R6'
			WHEX	R7'
			WHEX	R5
			WHEX	R6
			WHEX	R7


			TMB		@2*R5'(WP),0	;Is AC' Negative?
  			JNE		ADD1			; No
			B		@SUB1			;Yes => SUB1

ADD1:   	LI	R0,0051H
			WHEX R0

			MOVB	@2*R7'+1(WP),R0	;Is AC' zero?
			JNE		ADD1A
       		RET  		      		;Yes => Return
;
; At this point we have AC and AC' populated and we know
; that AC' is both non zero and positive
;
ADD1A:      LI	R0,004BH
			WHEX R0

			MOVB	@2*R7+1(WP),R0	;Is AC zero?
        	JNE		ADD2    		;No => ADD2
        	TCMB	@2*R5'(WP),0	;Make AC' Positive
         	JMP   	ADD10

ADD2:   	LI	R0,0CCCCH
			WHEX R0
			MOV		R5,R4			;Save AC sign for next operation
			LI		R8,SIGN*256
         	SOCB	R8,R5			;Set AC MSB as Negative
         	SOCB	R8,R5'			;Set AC' MSB as Negative
         	CLR		R8				;Need to clear LSB for for ADD3
         	MOVB	@2*R7+1(WP),R0	;EXP
         	MOVB	@2*R7'+1(WP),R8	;EXP'
          	SB		R0,R8	        ;R8 => EXP'- EXP (MSB)
        	JEQ		ADD4     		;EXP = EXP' => ADD4
        	JOC		ADD3    		;EXP < EXP' => ADD3
;
;	Negative difference so we have to make positive
;   R8 behaves as an AF AF' pair MSB is AF and LSB is AF'
;
        	NEG		R8         		;Make R8 MSB positive
        	ANDI	R8,0FF00H		;Mask of Low Byte
        	CALL	@EXX			;We have to adjust AC'
;
;	R8 HOLDS THE DIFFERENCE OR ADJUSTMENT NEEDED
;   IF EXP < EXP' ADJUST EXP UP
;   IF EXP > EXP' ADJUST EXP' UP
;

ADD3:		LI		R0,0066H
			WHEX 	R0

			CALL 	@SRIGHT     	;Shift AC to the right by 1 position
			LI		R0,256
			AB		R0,@2*R7+1(WP)	;Increment exponent and check if  EXP=EXP'?
        	AI  	R8,-256    		;DEC difference
          	JNE	 	ADD3    		;No => ADD3
          	SWPB	R8				;Equivalent to EX AF, AF'
          	MOVB	R8,R0			;Was it AC'
          	JEQ		ADD4			;No => ADD4
          	CALL	@EXX			;Yes=>Exchange for for AC

; First check if the incoming AC was negative so we can reapply sign
ADD4:   	LI		R0,0041H
			WHEX 	R0

			TMB		@2*R4(WP),0		;Was R5 (AC) MSB negative?
 			JEQ		ADD5	   		;If it is negative => ADD5

        	CALL 	@ADDAC      	;MANT=MANT+MANT'
        	JNC		ADD9    		;No carry/overflow then => ADD9
;
; There has been an overflow so we need to rotate the mantissa to the right 1 place
;
			LI		R0,0042H
			WHEX 	R0
        	SETO	R0				;Set for carry
        	CALL 	@RIGHT      	;Rotate to the right
        	LI		R0,256
        	AB		R0,@2*R7+1(WP)	;Increment the exponent by 1
 	        JNE		ADD9
	        JMP		ADD10

ADD5:   	LI		R0,0043H
			WHEX 	R0
;    			AC=AC' => JEQ.
;               AC>AC' => JGT
;               AC<AC' => JLT.

			CALL 	@CMPAC      	;Compare
			STST	ST				;Save the status register
			LI		R0,AGT			;Arithmetic Greater Than Bit Mask
			XOR		R0,ST			;Complement the carry bit
			LST		ST				;Load the stutus register
        	JEQ		ADDZ     		;AC=AC' => ADDZ
        	JGT		ADD6     		;AC>AC' => ADD6
			CALL	@EXX			;AC<AC' => Swap

ADD6:   	CALL 	@SUBAC      	;MANT=MANT-MANT'

ADD7:   	TMB		@2*R5(WP),0		;Test the sign bit - is it normalised
			JEQ		ADD8			;Yes => ADD8
        	CALL 	@SLEFT      	;Shift left one bit
        	MOVB	@2*R7+1(WP),R0
         	JEQ		ADDZ     		;No  => AC zero
        	AI	  	R0,-1*256 		;Subtract 1 from the exponent
        	MOVB	R0,@2*R7+1(WP)	;Update exponent
        	JMP		ADD7

ADDZ:   	CALL 	@ZERO

ADD8:   	LI		R0,0044H
			WHEX 	R0
			LST		ST         		;Get sign from ADD5 Compare
ADD9:   	JGT		ADD10    		;Carry => negative

			TCMB	@2*R5(WP),0		;Clear sign bit
;
;  Common routine need to check if it is correct
;
ADD10:  	LI	R0,0045H
			WHEX R0
			CALL	@PUTAC			;Put AC into the FPA
        	RET

;
;
;FLOATING POINT SUBTRACTION
;;
;	subtract the floating point accumulator (AC) from the value
;	on the stack (AC') (under the return address), leave result
;	in the floating point accumulator.
;     Subtraktion
;     ------------
;
;     NAME:      FPSUB
;     FUNCTION:  AC=AC-AC'. The number in AC' is subtracted from
;                the number in AC and the result is placed in AC.
;     OFFSET:    03H
;     OUTPUT:    CF=0: OK.
;                CF=1: Overflow.
;     STACK:     12 bytes.;
;
;
_fpsub::   	LI	R0,000AH
			WHEX R0
			STWP	WP				;Need to offset into wp for some operations
;
;	add the value on the stack (under the return address)
;	to the floating point accumulator
;

			POP		R4					;save return address
			POP		R7'					;Get AC'
			POP		R6'
			POP		R5'
			PUSH	R4					;replace return address


			LI		R0,0066H
			WHEX	R0
			CALL	@GETAC
			CALL	@EXX				;Now we have AC - AC'

;			WHEX	R5'
;			WHEX	R6'
;			WHEX	R7'


			TMB		@2*R5'(WP),0		;Is AC' negative?
			JNE		SUB1				;Yes => ADD1
			B		@ADD1

SUB1:   	CALL 	@FPNEG      		;AC=-AC
        	CALL 	@ADD1       		;Add AC' to  AC
;        	CALL 	@FPNEG
        	CALL	@PUTAC
        	RET


;FLOATING POINT DIVISION.
; For a flowchart of the algorithm
; see BYTE Magazine Volume 2, issue 11 (November, 1977)
;
;
;     NAME:      FPDIV
;     FUNCTION:  AC=AC/AC'. The number in AC is divided by the
;                number in AC' and the result is placed in AC.
;     OFFSET:    09H
;     OUTPUT:    CF=0: OK.
;                CF=1: Overflow or AC' equal to 0.
;     STACK:     32 bytes.
;
;
;	divide the value on the stack (under the return
;	address) by the floating point accumulator, leave
;	result in the floating point accumulator.
;
;   Result is (ACs/AC's)x2^(EXP-EXP')
;
;  DIVIDEND = 2^2+2^3+2^4 etc
;	-------   ---------------
;  DIVISOR  = 2^2+2^3+2^4 etc
;
;

_fpdiv::
FPDIV: 		STWP	WP
			POP		R4					;save return address
			POP		R7'					;Get AC'
			POP		R6'
			POP		R5'
			PUSH	R4					;replace return address

			CALL	@GETAC
			CALL	@EXX				;Now are now ready for AC/AC'

			MOVB	@2*R7'+1(WP),R0		;Is AC' zero
        	JNE		DIVI_A
        	B		@MULSA1		       	;Yes => Overflow

DIVI_A:		MOVB	@2*R7+1(WP),R4		; Is AC zero?
        	JNE		DIVI_B
        	B		@MULSA1						        ;Yes, => Return

DIVI_B:		LI		R8,1111H
			WHEX	R8
			SB		R0,R4      			;Adjust exponent by calling EXPSGN

        	MOV		SP,R9				;R9 will be used as Workspace Pointer on the stack
        	AI		R9,-32				;Allocate Stack Registers R0 to R7. R5, R6, R7 holds the result
										;Higher registers are not used as they will be overwritten during calls
			LI		R0,5				;Use is 5 bytes, each with 8 bits
			MOV		R0,@2*R1(R9)		;R1 (STACK) hold number of bytes
			LI		R0,8				;Number of bits per byte
			MOV		R0,@2*R2(R9)		;R2 (STACK) hold number of bits
			CLR		R0					;Result offset byte.  Points to first byte initially
			MOV		R0,@2*R3(R9)		;R3 Offset Byte to point to result byte
			MOV		R0,@2*R5(R9)		;Clear the result
			MOV		R0,@2*R6(R9)		;Clear the result
			MOV		R0,@2*R7(R9)		;Clear the result
;
;  CALL EXPSGN to
;  1.Exclusive OR Signs to get Resultant Sign
;  2.Subtract Divisor Exponenet from Dividend Exponent
;  Place both these results onto the result space allocated on the stack
;
			CALL 	@EXPSGN     		;calculate sign i.e. (EXP-EXP')
			LI		R8,1112H
			WHEX	R8

DIVI1:		CLR		R4					;Clear Carry Flag
			CALL	@CMPAC				;Is MANT>MANT'
			JLT		DIVI2				;No =>DIVI2
			CALL	@SUBAC				;Subtract AC'from AC (Divident - Divisor)
			INC		R4

DIVI2:		MOV		@2*R3(R9),R8		;Get current result byte offset
			A		R9,R8				;R4 points to the current byte on the stack
			MOVB	@RES_BYTE(R8),R0	;get result or quotient
			SLA		R0,1
			MOV		R4,R4
			JEQ		DIVI2A
			INC		R0					;Add carry

DIVI2A:		MOV		R0,@RES_BYTE(R8)	;Copy temp buffer
			DEC		@2*R2(R9)			;more bits in this byte?
			JNE		DIVI3

			LI		R0,8				;Number of bits per bytes
			MOV		R0,@2*R2(R9)		;R2 (STACK) hold number of bits
			MOV		@2*R3(R9),R0		; Get current result offset
			INC		R0
			MOV		R0,@2*R3(R9)
			CI		R0,5				;Are we finished?
			JEQ		DIVI4

DIVI3:		CALL	@SLEFT				;Shift AC to the Left (Dividend is result of subtraction)
			JNC		DIVI1				;No carry => DIVI1

			CALL	@SUBAC				;MANT=MANT-MANT'
			CLR		R0					;Reset carry
			JMP		DIVI2

DIVI4:		CALL	@SLEFT				;;Calculate the rounding bit
			JOC		DIVI5
			CALL	@CMPAC


DIVI5:		TMB		@2*R5(WP),0			;Normalised?
			JEQ		DIVI6				;Yes => DIVI6

			CALL	@LEFT				;Rotate rounding bit
			JMP		MUL5				;into result

DIVI6:		INC		R7					;Add 1 to the exponent
			JNE		MUL5
			DEC		R7
			JMP		MUL5A

;FLOATING POINT MULTIPLIKATION
;     Multiplication
;     --------------
;
;     NAME:      FPMUL
;     FUNCTION:  AC=AC*AC'. The number in AC is multiplied by
;                the number in AC' and the result is placed in AC.
;     OFFSET:    06H
;     OUTPUT:    CF=0: OK.
;                CF=1: Overflow.
;     STACK:     16 bytes.
;


FPMUL:
_fpmul::
		LI	R0,001BH
		WHEX R0
		LI	R4,0
		CALL	@ZERO
		CALL	@PUTAC
		RET
MUL5:		CLR		R0
MUL5A:  	MOV		@2*R5(R9),R5			;Move result into AC
			MOV		@2*R6(R9),R6			;Move result into AC
			MOV		@2*R7(R9),R7			;Move result into AC
			MOVB	@2*R7+1(R9),R0
			JNE		MULSA1
			CALL	@ZERO
MULSA1:		CALL	@PUTAC
			RET



;
;Adjust exponent and calculate sign.
; Value of exponent is in R4
; R9 points to the workspace on the stack
;
;

EXPSGN:		JLT		EXPS1				;If less than => EXPS1
			LI		R0,EXPN*256
			AB		R0,R4				;Adjust exponent for radix 2
			JNO		EXPS2				;No overflow => EXPS2
			JMP		EXPS3				;Underflow


EXPS1:		LI		R0,EXPN*256
			AB		R0,R4				;Adjust exponent for radix 2
			JNO		EXPS2
			JMP		EXPS3				;Overflow


EXPS2:		LI		R8,1115H
			PUSH	R8
			WHEX	R8
			POP R8

			MOVB	R4,@2*R7+1(R9)		;This is the resultant EXPN

			MOVB	@2*R5'(WP),R0		;Get AC' Sign
			TSMB	@2*R5'(WP),0		;Set both of them to 1
			TSMB	@2*R5(WP),0			;Calculate new sign
			XOR		@2*R5(WP),R0		;XOR to determine resultant sign
			XOP		@2*R5(WP),1
			MOVB	R0,@2*R5(R9)		;Sign of resultant or quotient
			RET

EXPS3:		;Adjust stack?
			LI		R8,1113H
			PUSH	R8
			WHEX	R8
			POP		R8
			RET

;
; Complement the sign bit
;


FPNEG:  	MOVB	@2*R7+1(WP),R0   	;Is AC zero?
        	JEQ		FP_RET      	 	;Yes => Return
        	LI		R0,SIGN*256
       	 	XOR  	R0,R5				;Complement sign
FP_RET:     RET


MINUSFPA:
_minusfa::
			MOV		@FPA,R4
			LI		R0,SIGN*256
			XOR		R0,R4
			MOV		R4,@FPA
			RET

;
;Add AC 'to AC..Result in AC and set carry flag if applicable
;

ADDAC:  	CLR		R0				;This is the carry register
			INC		R0
			STST	ST				;Save status with no carry or overflow set
			AB		R7',R7
			JNC		AAC1
			A		R0,R6
			JNC		AAC1
			A		R0,R5
			JNC		AAC1
			STST	ST				;Carry to AC  has occured i.e. R5
; Now add the registers together

AAC1:		A		R6',R6
			JNC		AAC2
			A		R0,R5
			JNC		AAC2
			STST	ST				;Carry to AC has occured i.e. R5

AAC2:		A		R5',R5
			JNC		AAC3
			STST	ST				;Carry to AC has occured i.e. R5
AAC3:		LST		ST
            RET

;
;Subtract AC'from AC. - Set ST1 = 0 if LT, ie AC<AC'
;
SUBAC:  	LI	R0,0005H
			WHEX R0
	  		CLR		R0				;Clear carry and prime carry bit
			INC		R0
			STST	ST				;Save status with no carry or overflow set
			SB		R7',R7
			JNC		SAC1
			A		R0,R6'
			JNC		SAC1
			S		R0,R5'
			JNC		SAC1
			STST	ST				;Carry to AC  has occured from. R5
;
; Now subtract the registers AC - AC'
;
SAC1:   	S		R6',R6
			JNC		SAC2
			A		R0,R5'
			JNC		SAC2
			STST	ST   			;Carry to AC  has occured from R5

SAC2:		S		R5',R5			;
			JNC		SAC3
			STST	ST
SAC3:		LST		ST
 			RET
;
;Compare AC to AC '
;
;
;     NAME:      CMP
;     FUNCTION:  Compare AC to AC' using subtraction, i.e. AC - AC'.
;     OFFSET:    12H
;    			ST2=1: 			AC=AC' => JEQ.
;               ST0=1 ST2=0: 	AC>AC' => JGT.
;               ST0=3 			AC<AC' => JLT.
;     STACK:     2 bytes
;
;
CMPAC:  	LI		R0,0006H
			WHEX 	R0
			C		R5,R5'
			JEQ		CMP1
			JMP		CMP_RET

CMP1:		C		R6,R6'
			JEQ		CMP2
			JMP		CMP_RET

CMP2:		CB		R7,R7'

CMP_RET:  	RET
;
;	Double precision comparisons
;
;	each compares top of stack
;	(under two return addresses) to FA
;
;TOS >= FA?
;
_fpge::		CALL	@DCOMPAR
			JEQ		YES			;z => equal
			JEQ		DG			;remaining tests are shared
;
;TOS > FA?
;
_fpgt::		CALL	@DCOMPAR
			JEQ		NO			;z => equal
DG:			JMP		NO			;p => not greater than
YES:		LI		R4,1		;load "true"
			RET

;
;TOS <= FA?
;
_fple::		CALL	@DCOMPAR
			JEQ		YES
			JMP		DL
;
;TOS < FA?
;
_fplt::		CALL	@DCOMPAR
			JEQ		NO
DL:			JLT		YES			;p => less than
NO:			CLR		R4			;load "false"
			RET
;
;TOS == FA?
;
_fpeq::		CALL	@DCOMPAR
			JEQ		YES
			JMP		NO

;
;TOS != FA?
;
_fpne::		CALL	@DCOMPAR
			JEQ		YES
			JMP		NO


;
;FLOATING POINT COMPARE.  TEST IF EQUAL.
;
;common routine to perform double precision comparisons


DCOMPAR:
			LI	R0,0006H
			WHEX R0
			POP		R0	;save 1st return addr
			POP		R1	;save 2nd return addr
			POP		R7  ;get number to compare
			POP		R6
			POP		R5
			PUSH	R1	;replace 2nd addr
			PUSH	R0	;replace 1st addr, fall into...
;CMP:
 			RET
;		EXX             ;Er fortegn ens?
;        LD   A,B
;        EXX
;        XOR  B
;        JP   P,CMP1     ;Ja => CMP1
;        LD   A,B        ;Fortegn fra AC til
;        RLA             ;carry
;        RET

;CMP1: ;  BIT  7,B        ;Negative tal?
 ;       JR   Z,CMP2     ;Nej => CMP2

;        CALL CMP2       ;Sammenlign abs.vaerdi
 ;       RET  Z          ;Ens => Returner
;        CCF             ;Complementer resultat
;        RET

;CMP2:;   LD   A,L        ;Er exponenter ens?
;        EXX
;        CP   L
;        EXX
;        RET  NZ         ;Nej => Returner
;        OR   A          ;Er exponenter nul?
;        RET  Z          ;Ja => Returner
;        JP   CMPAC      ;Sammenlign AC med AC'


;
;CONVERT A FLOATING POINT A 16 BIT INTEGER USES AC
;
;     Integer
;     -------;
;
;     NAME:      INT
;     FUNCTION:  AC>=0: AC is set equal to the nearest integer that is
;                       less than or equal to the number in AC.
;                AC<0:  AC is set equal to the nearest integer that is
;                       larger than or equal to the number in AC.
;     OFFSET:    30H
;     STACK:     8 bytes.
;     EXAMPLE:   INT(3.7)=3
;                INT(-3.7)=-3

INT:    	LI		R0,0007H
			WHEX 	R0

			STWP	WP
			LI		R0,256*EXPN+1
			MOVB	@2*R7+1(WP),R4      ;Is exponentially smaller
        	SB  	R0,R4 				;than zero? DA-SA => DA
        	JNC		INT1A
        	B		@ZERO     			;Yes => Result zero

INT1A:      INC  	R4					;Add 1 to include the sign bit
			CALL	@EXX				;Exchange into AC'
			CALL	@ZERO				;Zero AC which will be the mask

INT1:   	SETO	R0					;Used for carry. Carry flag sets all the bits that have
        	CALL 	@RIGHT      		;than or equal to zero
        	DEC  	R4
        	JNE		INT1

        	SZCB	R7',R7				;We now have the mask in AC' so AND all bits in AC
        	SZC		R6',R6				;that has an exponent
        	SZC		R5',R5				;less than using AND
        	CALL	@EXX				;Now have AC
INT2:   	B		@ADD10      		;Put it into FPA


;
;	negate FA, and push address of MINUSFA
;	called to evaluate functions f(x) when the argument is
;	negative and f() satisfies f(-x)=-f(x)
;
ODD:		LI	R0,0008H
			WHEX R0
			CALL	@MINUSFPA
			LI		R0,MINUSFPA
			MOV		*SP,R4
			MOV		R0,*SP
			B		*R4



; CONVERT THE 16-BIT INTEGER IN R4 WITH 2'S COMPLEMENT SIGN
; TO FLOATING POINT NUMBER AND PLACE IN FPA.
; AC IS REPRESENTED BY R5, R6 AND R7
;
;     Convert 16-bit integer to a floating point number
;     -------------------------------------------------
;
;
;     NAME:      FLOAT
;     FUNCTION:  AC=FLOAT(R4). Convert the 16-bit 2's complement
;                integer in R4 to floating point number format
;                and save the result in AC and copy AC to FPA
;     OFFSET:    3FH
;     STACK:     2 bytes.
;     EXAMPLE:   FLOAT(0001H)=1
;                FLOAT (FFFFH)=-1

float::
_float::	LI	R0,000BH
			WHEX R0

			STWP	WP			;We may need this
			MOV		R4,R0        ;Is R4=0?
        	JEQ		ZERO         ;YES => ZERO

			SLA		R0,1		;Is bit 8 negative?
			STST 	ST			;Save sign in ST via status register
			JNC		FLT1		;No => FLT1
			NEG		R4			;Take 2's complemnet ST2 is unchanged

FLT1:  	 	MOV		R4,R5		;Set mantissa
        	CLR		R6
        	CLR		R7
        	LI		R4,EXPN+16	;Set inital value of exponent so we can normalise

FLT2:   	MOV		R5,R0
			SLA		R0,1        ;Now inovke the Normaliser
        	JEQ		FLT3		;If MSB is set then we have finished?
        	CALL 	@SLEFT		;No, so move R5,R6 and R7 one position to the left
        	DEC  	R4			;Adjuat the exponent
        	JMP		FLT2

FLT3:   	MOVB	@2*R4+1(WP),@2*R7+1(WP)  ;Update the exponent
			LST		ST     		;Was the original integer value negative?
        	JOC		FLT4   		;Yes => Return
        	ANDI	R5,7FFFH	;Clear Most Significant sign Bit
FLT4:      	CALL	@PUTAC		;Save the number in the FPA
      		RET

;
;Reset AC. (R5, R6 and R7)
;
ZERO:   	CLR		R5  		;Reset carry, exponent of mantissa      ;
        	CLR		R6
        	CLR		R7
        	CALL	@PUTAC		;Save the number in the FPA
	        RET

;
;Rotate AC to the right - Can only use R0. R0 will determine in carry in occurs
;
SRIGHT:		CLR		R0			;Clear carry flag
RIGHT: 		MOV		R0,@-2(SP)	; Save the carry flag by using stack space

RSR1:		MOV		R7,R0		;Preserve R7 and shift copy in R0
  			SRL		R0,1		;Not concerned about carry for R7
			MOVB	R0,R7		;Restore R7 and the exponent and Now check for R6 carry into R7
			SRL		R6,1		;If carry we need to add to R7
			JNC		RSR5
			ORI		R7,SIGN*256	;Set MSB

RSR5:		SRL		R5,1
			JNC		RSR6
			ORI		R6,SIGN*256	;Set MSB

RSR6:		MOV		@-2(SP),R0	;Get it back from the stack space to check the carry in flag
			SLA		R0,1
			JNC		RSR7
			ORI		R5,SIGN*256	;Set MSB

RSR7:		RET



;
;Rotate AC to the left.
;

SLEFT:  	CLR		R0
LEFT:   	SLA		R5,1			;R5 HOLDS THE MSB OF THE FP
			SLA		R6,1			;SHIFT R5,R6 AND R7 TO THE LEFT ONE BIT
			JNC		LSR7
			INC		R5				;Add the carry to R5
LSR7:		MOVB	@2*R7+1(WP),R0	;Need to preserve exponent
			SLA		R7,1
			JNC		LSR8
			INC		R6
LSR8:		MOVB	R0,@2*R7+1(WP)	;Copy back the exponent
			RET

;
;
;FLOATING POINT TO 16-BIT INTEGER (IN FPA ) WITH
;2'S COMPLEMENT SIGN.
;
;THE BITS THAT WE NEED TO GRAB ARE IN THE MSB OF THE
;FLOATING POINT REPRESENTATION, I.E.  REGISTERS R5 AND R6
;
;
;
;     Convert floating point number to a 16-bit integer
;     -------------------------------------------------;
;
;     NAME:      FIX.
;     FUNCTION:  HL=FIX(AC). convert the integer part of the floating
;                number in AC to a 16-bit 2's complement integer, and
;                save the result in the R4 register.
;     OFFSET:    3CH
;     OUTPUT:    CF=0: OK.
;                CF=1: ABS(INT(AC)) > 32767
;     STACK:     2 bytes.
;     EXAMPLE:   FIX(1.5)=    1=  0001H
;                FIX(-1.5)=  -1=  FFFFH
;                FIX(0.5)=    0=  0000H
;
_ifix::
ifix::		LI		R7,2222H
			WHEX	R7
			STWP	WP
   			CALL	@GETAC			;Get FPA into R5, R6 and R7
   			TMB		@2*R7(WP),8		;Exponent < 0?  MSB is bit 8
 			JNE		FIX4			;Yes => FIX4 as greater than zero
   			TSMB	@2*R5(WP),0		;Test an set sign bit for shift operations not sign
  			STST	ST				;Remember state of sign test

        	MOV		R7,R4			;Work on a copy of the exponent now
        	SWPB	R4

FIX1:		LI		R0,EXPN+15		;Test exponent to see if it is lower than (0x8F)
			SWPB	R0				;Move to MSB
      		SB		R4,R0			;too large to be an integer
        	JHE		FIX1A
        	JMP		FIX4			;EXP>15 => overflow

FIX1A:      JEQ		FIX2			;EXP=15 => FIX2
        	CALL 	@SRIGHT     	;EXP<15 => rotate to
        	AI		R4,256		  	;right and add 1 more to
        	MOVB	R4,@2*R7+1(WP)	;Update exponent
        	JMP   	FIX1	       	; Keep going

FIX2: 		CALL 	@SRIGHT     	;Rotate to the right
        	LST		ST				;Load status register from sign test
        	JNE   	FIX3     		;Negative sign?  No => INT2
; 			WHEX	R5
        	NEG		R5       		;Convert to 2's complement
;        	WHEX	R5
        	MOV		R5,R4
        	RET

FIX3:   	MOV		R5,R4        	;Get the final integer into R4
        	RET

FIX4:   	CLR		R4       		;Underflow, return -32768
        	RET


;
;	return -(floor(-x))
;
CEIL::
_ceil::		CALL	@ODD
;
;   Return largest integer not greater than floor(x) returns the nearest
;  integral value that is not greater than x. It is always true that
;  floor(x) <= x
;
;  see https://stackoverflow.com/questions/24158625/is-it-possible-for-floor-to-return-an-inaccurate-result-due-to-floating-point#:~:text=The%20floor()%20function%20returns,that%20is%20an%20exact%20integer.&text=In%20other%20words%2C%20the%20true,arithmetic%20is%20less%20than%20i%20.

;floor(x) <= x
FLOOR::
_floor::	B		@_ifix			;temporary floor

			MOVB	@FPA,R1			;Get sign bit
			MOVB	@FPA+5,R4		;fetch exponent
			CI		R4,	0D9H*256	;(was A8H) larget negative exponent
			JOC		FLR1
			RET						;nc => binary point is right of lsb

FLR1:		CALL	@INT
			RET
;
;Set carry if the grade in A is a digit.

;GDTST:  	LD   A,(IX+0)
;DIGTST: 	SUB  '0'
;        	CCF
 ;       	RET  NC
;        	CP   10
;        	RET
;
;DUPLICATE EQUIVALENT TO Z80 EXX
;
EXX:		MOV		R5,R0
			MOV		R5',R5
			MOV		R0,R5'

			MOV		R6,R0
			MOV		R6',R6
			MOV		R0,R6'

			MOV		R7,R0
			MOV		R7',R7
			MOV		R0,R7'
			RET
;
;DUPLICATE EQUIVALENT TO Z80 EX FOR EXCHANGING STATUS REGISTERS
;
EXSR:		STST	R0			;SAVE CURRENT STATUS REGISTER
			LST		ST			;LOAD PREVIOUS STATUS REGISTER
			MOV		R0,ST		;SAVE CURRENT STATUS REGISTER IN SR
			RET
;
;GET FLOATING POINT NUMBER FROM FPA CONTENTS INTO R5, R6 AND R7
;
GETAC:		MOV		@FPA,R5
			MOV		@FPA+2,R6
			MOV		@FPA+4,R7
			RET
;
;PUT AC INTO FLOATING POINT ACCUMULATOR
;
PUTAC:		MOV		R5,@FPA
			MOV		R6,@FPA+2
			MOV		R7,@FPA+4
			RET

;
;PUT AC' INTO FLOATING POINT ACCUMULATOR
;
PUTACP:		MOV		R5',@FPA
			MOV		R6',@FPA+2
			MOV		R7',@FPA+4
			RET
;
;Set AC to 1.
;

AC1:    	LI		R5,00000H
        	LI		R6,00000H
        	LI		R7,00081H
        	RET
;
        	END
;------------END OF MATH48------------

